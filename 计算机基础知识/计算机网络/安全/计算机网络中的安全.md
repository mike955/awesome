# 计算机网络中的安全

---

## 网络安全

安全通信应该具有一下特征:
 - 机密性: 仅有发送发个希望的接收方能够理解传输报文的内容，因此需要对报文进行加密
 - 报文完整性: 报文在传输过程中应该确保未被改变，因此需要对报文完整性进行检验
 - 端点鉴别(通信对方确定性): 发送方和接收方应该证实与之通信的另一方的身份，因此需要进行端点鉴别
 - 运行安全性: 保证通信过程的安全行，因此需要防火墙等手段

## 密码学原则

相关概念:
 - 明文: 报文的内容
 - 加密算法: 用来对报文进行加密
 - 密文: 加密算法对明文加密生成的加密报文
 - 密钥: 是一串数字或字符，作为加密算法的输入

相关公式:
 - 密文=加密算法(明文，密钥1)
 - 明文=解密算法(密文，密钥2)
 - 对称加密中，密钥1 与密钥2 相同，非对称加密中，密钥1 与 密钥2 不同

加密算法:
 - 对称加密算法:
  - DES、AES
 - 非对称加密算法:
  - RSA 

## 报文完整性
密码散列函数: 以 m 为输入，并计算的到一个称为散列的固定长度的字符串 H(m)

常见散列算法:
 - MD5
 - SHA-1、SHA256

报文完整性执行过程(v1):
1. 发送方生成报文 m 并计算散列 H(m)
2. 发送方将 H(m) 附加到报文 m 上，生成一个扩展报文(m, H(m))，将扩展报文发送给接收方
3. 接收方收到扩展报文(m, h)，并计算 H(m)，如果 H(m)=h，则确定结果正确

上面的报文完成性执行过程存在一个问题，窃密者挣够生成虚假报文 m，并且声称自己就是发送方

报文完整性执行过程(v2):
1. 发送方生成报文 m ,用 s(鉴别密钥 authentication key) 级联 m 生成 m + s，并计算散列值 H(m+s)，H(m+s)称为报文鉴别码(MAC)
2. 发送方将 H(m+s) 附加到报文 m 上，生成扩展报文(m, H(m+s)),将扩展报文发送给接收方
3. 接收方收到扩展报文(m, h)，因为接收方知道 s，计算 H(m+s)=h，确定结果

## 数字签名
数字签名应当可以以可以鉴别的、不可伪造的方式进行，必须能够证明由某个人在一个文档上的签名确实是由该人签署的，且只有那个人能够签署那个文件。

常用的方式是利用私钥对报文进行签名(签名指利用某人的私钥和报文作为加密算法的参数生成密文的过程); 当报文很大时加密解密的计算代价很大，因此使用下面的步骤进行签名:
 - 对报文进行散列，生成固定长度的散列报文
 - 对散列报文进行签名，生成签名的散列
 - 将签名的散列发送给接收方

数字签名的一种重要应用是**公钥认证**，即正式一个公钥属于某个特定的实体，将公约与特定实例绑定通常是由认证中心(CA)完成的。CA的职责就是使识别和发行证书合法化。

CA会生成一个把其身份和实体的公钥绑定起来的证书(certificate)，这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息。

## 端点鉴别

## SSL

### SSL、TSL、HTTPS关系
TLS 是 SSL 的新名称，TLS 1.0 是 SSL 3.1；HTTPS 是 HTTP 与 SSL/TLS 的结合；SSL（TLS）为两台主机之间的任意二进制数据建立安全的双向隧道。HTTP 是用于发送请求和接受响应的协议，每个请求个响应由头部和内容组成，HTTP 运行在一个二进制传输的双向通道上，该通道由 SSL/TLS 建立，因此称作 HTTPS。

SSL 表示安全套接字层，TLS 表示传输层安全性，更改名字是为和避免相关法律问题（SSL 由网景公司发明）。

### SSL 握手过程
1. client 向 server 发送它支持的密法算法列表，连同一个客户的不重数
2. server 从收到的列表中选择一种对称算法(如 AES)、一种公钥算法(如RSA)和一种 MAC 算法，把选择的算法及证书和一个服务器不重数返回给 client
3. client 验证该证书，提出服务器的公钥，生成一个**前主密码(pre-master secret PMS)**，用服务器的公钥加密该 PMS，并将加密的 PMS 发送给服务器
4. 使用相同的密钥导出函数，client 和 server 独立地从 PMS和不重数中计算出主密钥(Master Secret, MS)，然后该 MS 被切片以生成两个密码和两个 MAC 密钥。此外，当选择的对称密钥应用于 CBC(例如 3DES 或 AES)，则两个初始化向量( Initialization Vector, IV) 也从该 MS 获得，这两个 IV 分别用与该连接的两端，自此以后，client 和 server 之间发送的所有报文均被加密和鉴别( 使用 MAC )
5. client 发送所有握手报文的一个 MAC 
6. server 发送所有握手报文的一个 MAC