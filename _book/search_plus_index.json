{"./":{"url":"./","title":"Introduction","keywords":"","body":"Start npm install docsify -g docsify serve ./notes open localhost:3000 in browser "},"Angular/":{"url":"Angular/","title":"Angular","keywords":"","body":""},"Angular/knowledge/architecture.html":{"url":"Angular/knowledge/architecture.html","title":"architecture","keywords":"","body":"Angular architecture 架构概览 组件 模板、指令和数据绑定 服务与依赖注入 路由 Angular 组件关系图 架构概览 Angular 是一个用 HTML 和 TypeScript 构建客户端应用的平台 Angular 的基本构造是 NgModule，它为组件提供了编译的上下文环境，Angular 应用就是游一组 NgModule 定义出的 组件定义视图，Angular 根据你的程序逻辑和数据来选择和修改它们 组件使用服务，服务提供商可以作为依赖注入到组件中 组件和服务都是简单的类，使用修饰器来标出它们的类型 组件 每个 Angular 应用都至少有一个组件，也就是根组件，它会把组件树和页面中的 DOM 连接起来 @Component 修饰器表明紧随它的那个类是一个组件 模板、指令和数据绑定 模板会把 HTML 和 Angular 的标记组合起来 模板中的指令提供程序逻辑，绑定标记会吧应用中的数据和 DOM 连接在一起 事件绑定让应用通过更新应用数据来响应输入 属性绑定让应用程序计算出来的值插入到 HTML 中 可以用管道来转换显示的值 服务与依赖注入 让与视图无关的数据或逻辑可以被多个组件共享 服务类的定义紧跟在 @Injectable 后，改修饰器提供的元数据可以让你的服务作为依赖被注入到客户组件中 路由 定义应用的各个不同的状态和视图层次结构之间导航时要使用的路径 Angular 组件关系图 组件和模板共同定义了 Angular 的视图 组件类上的修饰器为其添加了元数据，其中包括指向相关模板的指针 组件模板中的指令和绑定标记会根据程序数据和程序逻辑修改这些视图 依赖注入器会为组件提供一些服务，比如路由器服务就能让你定义如何在视图之间导航 "},"Angular/knowledge/bootstrapping.html":{"url":"Angular/knowledge/bootstrapping.html","title":"bootstrapping","keywords":"","body":"引导启动 引导启动 启动过程 declarations 数组 通过 @NgModule 使用指令 imports 数组 providers 数组 bootstrap 数组 启动过程 NgModule 用于描述应用的各个部分如何组织在一起，每个应用至少有一个 Angular 模块，根模块是用来启动此应用的模块，命名通常为 AppModule 使用 CLI 生成的应用，默认的 AppModule 如下: /* JavaScript imports */ import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { FormsModule } from '@angular/forms'; import { HttpModule } from '@angular/http'; import { AppComponent } from './app.component'; /* the AppModule class with the @NgModule decorator */ @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, FormsModule, HttpModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } @NgModule 修饰器表明 AppModule 是一个 NgModule类，@NgModule 获取一个元数据对象，它告诉 Angualr 如何编译和启动本应用 * declaration - 该应用所拥有的组件 * imports - 导入 BrowserModule 以获取浏览器特有的服务，比如 DOM 渲染、无害化处理和位置(location) * providers - 各种服务提供商 * bootstrap - 根组件，Angular 创建它并插入 index.html 宿主页面 默认的 CLI 应用只有一个组件 AppComponent，所以它会同时出现在 declarations 和 bsststrap 数组中 declarations 数组 declarations 数组表示哪些组件属于该模块，创建新模块时，应该把其加入 declarations 中 每个组件都应该(且只能)声明在一个 NgModule 类中，使用为声明的组件会报错 declarations 数组只能接收可声明对象，可声明对象包括组件、指令和管道;一个模块的所有声明对象都必须放在 declarations 数组中;可声明对象必须只能属于一个模块，同一个类被声明在多个模块中会报错 可声明类在当前模块中时可见的，对其它模块中的组件是不可见的 每个可声明对象就只能属于一个模块，只能把它声明在一个 @NgModule 中 通过 @NgModule 使用指令 使用 declarations 数组声明指令，在模块中使用指令、组件或管道步骤如下： 从编写的文件中导出指令、组件、或管道 把它导入到适当的模块中 在 @NgModule 的 declarations 数组中声明它 // 导出指令 import { Directive } from '@angular/core'; @Directive({ selector: '[appItem]' }) export class ItemDirective { // code goes here constructor() { } } // 导入指令 import { ItemDirective } from './item.directive'; // 把指令添加到 @NgModule 的 declarations 数组中 declarations: [ AppComponent, ItemDirective ], // 经过上面三个步骤后就可以在组件中使用 ItemDirective 指令了 imports 数组 模块的 imports 数组只会出现在 @NgModule 元数据对象中 列表中的模块导出了本模块中的各个组件模板中所引用的各个组件、指令或管道 providers 数组 providers 数组中列出了该应用所需的服务，当直接把服务列在这里时，它们时全应用范围的 bootstrap 数组 应用时通过引导根模块 AppModule 来启动的，根模块还引用了 entryComponent; 引导过程还会创建 bootstrap 数组中列出的组件，并把它们逐个插入到浏览器的 DOM 中 每个被引导的组件都是它自己的组件树的根，插入一个被引导的组件通常触发一系列组件的创建并形成组件树 大多数应用只有一个组件树，并且只从一个根组件开始引导，根组件通常叫做 AppComponent,并且位于根模块的 bootstrap 数组中 "},"Angular/knowledge/httpClient.html":{"url":"Angular/knowledge/httpClient.html","title":"httpClient","keywords":"","body":"HttpClient Angular 中的 HttpClient 类给予 XMLHttpRequest 接口 HttpClient 准备工作 获取 JSON 数据 为什么要写服务 带类型检查的响应 读取完整响应 错误处理 获取错误详情 retry() 可观察对象(Observable)与操作符(operator) 请求非 JSON 格式数据 把数据发送给服务器 添加请求头 发起一个 POST 请求 发起 DELETE 请求 发起 PUT 请求 高级用法 配置请求 请求的防抖 switchMap() 拦截请求和响应 监听进度事件 准备工作 导入 Angular 的 HttpClientModule，可以在根模块 AppModule 中导入 根模块导入 HttpClientModule 后，可以把 HttpClient 注入到应用类中 根模块导入 HttpClientModule // app.module.ts import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http'; @NgModule({ imports: [ BrowserModule, // import HttpClientModule after BrowserModule. HttpClientModule, ], declarations: [ AppComponent, ], bootstrap: [ AppComponent ] }) export class AppModule {} 把 HttpClient 注入到应用类中 // config/config.service.ts import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; @Injectable() export class ConfigService { constructor(private http: HttpClient) { } } Back To TOC 获取 JSON 数据 // assets/config.json { \"heroesUrl\": \"api/heroes\", \"textfile\": \"assets/textfile.txt\" } // app/config/config.service.ts configUrl = 'assets/config.json'; getConfig() { return this.http.get(this.configUrl); // 通过 HttpClient的 get() 方法取得这个文件 } 下面的服务返回配置数据的 Observable 对象，所以组件要订阅 (subscribe) 该方法的返回值，订阅时的回调函数会把这些数据字段复制到组件的 config 对象中，它会在组件的模板中绑定 // app/config/config.component.ts showConfig() { this.configService.getConfig() .subscribe((data: Config) => this.config = { heroesUrl: data['heroesUrl'], textfile: data['textfile'] }); } Back To TOC 为什么要写服务 最佳实践：把数据展现逻辑从数据访问逻辑中拆分出去，包装进一个单独的服务，并且在组件中把数据访问逻辑委托给这个服务 Back To TOC 带类型检查的响应 订阅的回调需要用括号中的语句来提取数据的值 .subscribe((data: Config) => this.config = { heroesUrl: data['heroesUrl'], // 不能写成 data.heroesUrl，因为 get() 方法会把 JSON 响应体解析成匿名的 OBject 类型 textfile: data['textfile'] }); 定义响应体的类型 // app/config/config.service.ts export interface Config { heroesUrl: string; textfile: string; } getConfig() { // now returns an Observable of Config return this.http.get(this.configUrl); } // app/config/config.component.ts export interface Config { heroesUrl: string; textfile: string; } config: Config; showConfig() { this.configService.getConfig() // clone the data object, using its known Config shape .subscribe((data: Config) => this.config = { ...data }); } Back To TOC 读取完整响应 通过 observe 选项来获取 HttpClient 完整响应体 返回的 Observable 是一个 HttpResponse 类型 getConfigResponse(): Observable> { return this.http.get( this.configUrl, { observe: 'response' }); } showConfigResponse() { this.configService.getConfigResponse() // resp is of type `HttpResponse` .subscribe(resp => { // display its headers const keys = resp.headers.keys(); this.headers = keys.map(key => `${key}: ${resp.headers.get(key)}`); // access the body directly, which is typed as `Config`. this.config = { ... resp.body }; }); } Back To TOC 错误处理 在 .subscribe() 中添加第二个回调函数获取错误处理 // 返回的错误类型为 HttpErrorResponse showConfig() { this.configService.getConfig() .subscribe( (data: Config) => this.config = { ...data }, // success path error => this.error = error // error path ); } 获取错误详情 添加错误处理函数处理错误 private handleError(error: HttpErrorResponse) { if (error.error instanceof ErrorEvent) { // A client-side or network error occurred. Handle it accordingly. console.error('An error occurred:', error.error.message); } else { // The backend returned an unsuccessful response code. // The response body may contain clues as to what went wrong, console.error( `Backend returned code ${error.status}, ` + `body was: ${error.error}`); } // return an observable with a user-facing error message return throwError( 'Something bad happened; please try again later.'); }; getConfig() { return this.http.get(this.configUrl) .pipe( catchError(this.handleError) // 获取 HttpClient 方法返回的 Observable,并通过管道传给错误处理器 ); } retry() 如果 HttpClient 方法调用错误进行重试 getConfig() { return this.http.get(this.configUrl) .pipe( retry(3), // retry a failed request up to 3 times catchError(this.handleError) // then handle the error ); } 可观察对象(Observable)与操作符(operator) 请求非 JSON 格式数据 getTextFile(filename: string) { // The Observable returned by get() is of type Observable // because a text response was specified. // There's no need to pass a type parameter to get(). return this.http.get(filename, {responseType: 'text'}) // 请求 text 类型的数据 .pipe( tap( // Log the result or error data => this.log(filename, data), error => this.logError(filename, error) ) ); } 把数据发送给服务器 调用可观察对象的 subscribe() 方法之前，httpClient 不会发起 HTTP 请求 添加请求头 // 添加请求头 import { HttpHeaders } from '@angular/common/http'; const httpOptions = { headers: new HttpHeaders({ 'Content-Type': 'application/json', 'Authorization': 'my-auth-token' }) }; 发起一个 POST 请求 post 请求接受三个参数(url, 请求体数据, 请求头) /** POST: add a new hero to the database */ addHero (hero: Hero): Observable { return this.http.post(this.heroesUrl, hero, httpOptions) .pipe( catchError(this.handleError('addHero', hero)) ); } 发起 DELETE 请求 /** DELETE: delete the hero from the server */ deleteHero (id: number): Observable { const url = `${this.heroesUrl}/${id}`; // DELETE api/heroes/42 return this.http.delete(url, httpOptions) .pipe( catchError(this.handleError('deleteHero')) ); } 发起 PUT 请求 /** PUT: update the hero on the server. Returns the updated hero upon success. */ updateHero (hero: Hero): Observable { return this.http.put(this.heroesUrl, hero, httpOptions) .pipe( catchError(this.handleError('updateHero', hero)) ); } 高级用法 配置请求 可以对 HttpClient 方法最后一个参数中的配置对象进行配 // 修改请求头 httpOptions.headers = httpOptions.headers.set('Authorization', 'my-new-auth-token'); // 添加 URL 参数搜索 /* GET heroes whose name contains search term */ searchHeroes(term: string): Observable { term = term.trim(); // Add safe, URL encoded search parameter if there is a search term const options = term ? { params: new HttpParams().set('name', term) } : {}; return this.http.get(this.heroesUrl, options) .pipe( catchError(this.handleError('searchHeroes', [])) ); } 请求的防抖 {{package.name}} v.{{package.version}} - {{package.description}} withRefresh = false; packages$: Observable; private searchText$ = new Subject(); search(packageName: string) { this.searchText$.next(packageName); } ngOnInit() { this.packages$ = this.searchText$.pipe( debounceTime(500), distinctUntilChanged(), switchMap(packageName => this.searchService.search(packageName, this.withRefresh)) ); } constructor(private searchService: PackageSearchService) { } searchText$ 是一个序列，办好用户输入到搜索框中的所有值，它定义成了 RxJS 的 Subject对象，这表示它是一个多播 Observable，同时还可以自行调用 next(value) 来产生值。 除了把每个 serachText 的值都直接转发给 PackageSearchService 之外，ngOnInit() 中的代码还通过下列三个操作符对这些搜索值进行管道处理： debounceTime(500) - 等待，知道用户停止输入 500 毫秒 distinctUntilChanged() - 等待，知道搜索内容发生了变化 switchMap() - 把搜索请求发送给服务 代码把 pachages$ 设置成了使用搜索结果组合出的 Observable 对象，模板中使用 AsyncPipe 订阅了 package$，一旦搜索结果的值发回来了，搜索值才会传给服务 switchMap() switchMap() 操作符有三个重要特征 它的参数是一个返回 Observable 的函数，PackageSearchService.search 会返回 Observable，其它数据服务也一样 如果以前的搜索结果仍然是在途状态，它会取消哪个请求，并发起这个新的搜索 它会按照原始的请求顺序返回这些服务的响应，不用关心服务器实际上是乱序返回的它们 拦截请求和响应 HTTP 拦截机制是 @angular/common/http 中的主要特性之一 通过拦截机制，可以声明一些拦截器，用它们监视和转换从应用发送到服务器的 HTTP 请求 拦截器还可以用监视和转换从服务器返回到本应用的那些响应 多个选择器会构成一个“请求/响应处理器”的双向链表 监听进度事件 "},"Angular/knowledge/Observable&RxJS.html":{"url":"Angular/knowledge/Observable&RxJS.html","title":"Observable&RxJS","keywords":"","body":"Observable 与 RxJS Observable 与 RxJS 可观察对象 (Observable) 基本用法和词汇 定义观察者 订阅 创建可观察对象 多播 错误处理 RxJS 库 创建可观察对象的函数 操作符 常用操作符 错误处理 重试失败的可观察对象 可观察对象的命名约定 Angular 中的可观察对象 事件发送器 EventEmitter HTTP Async 管道 路由器 (router) 响应式表单(reactive forms) 用法实战 输入提示 (type-ahead) 建议 指数化退避 与其它技术的比较 可观察对象vs.承诺 可观察对象与承诺实现同样功能接口对比如下 可观察对象 (Observable) 可观察对象支持在应用中的发布者和订阅者之间传递消息 可观察对象是声明式的，只有消费时才会被执行 可观察对象可以发送多个任意类型的值 -- 字面量、消息、事件 基本用法和词汇 创建一个 Observable 实例，实例会定义一个订阅者 (subscriber) 函数，当消费者调用 subscriber() 方法时，该函数会被执行，订阅者函数用于定义“如何获取或生成那些要发布的值或消息” 从可观察对象中接收消息需要调用它的 subscriber() 方法，并传入一个观察者(observer)，observer 是一个 js 对象，定义接收消息的处理器(handler) subscribe() 调用会返回一个 Subscription 对象，该对象具有一个 unsubscribe() 方法，调用该方法时，会停止接收通知 // 使用可观察对象对当前地理位置进行更新 // Create an Observable that will start listening to geolocation updates // when a consumer subscribes. const locations = new Observable((observer) => { // Get the next and error callbacks. These will be passed in when // the consumer subscribes. const {next, error} = observer; let watchId; // Simple geolocation API check provides values to publish if ('geolocation' in navigator) { watchId = navigator.geolocation.watchPosition(next, error); } else { error('Geolocation not available'); } // When the consumer unsubscribes, clean up data ready for next subscription. return {unsubscribe() { navigator.geolocation.clearWatch(watchId); }}; }); // Call subscribe() to start listening for updates. const locationsSubscription = locations.subscribe({ next(position) { console.log('Current Position: ', position); }, error(msg) { console.log('Error Getting Location: ', msg); } }); // Stop listening for location after 10 seconds setTimeout(() => { locationsSubscription.unsubscribe(); }, 10000); 定义观察者 用于接收可观察对象通知的处理器要实现 Observer 接口，这个对象定义了一些毁掉函数来处理可观察对象可能会发来的三种通知 观察者对象可以定义这三种处理器的任意组合，如果部位某种通知类型提供处理器，这个观察者就会忽略相应类型的通知 通知类型 说明 next 必要，用于处理每个送达值，在开始执行后可能执行另次或多次 error 可选，用于处理错误通知，错误会终端这个可观察对象实例的执行过程 complete 可选，用与处理执行完毕(complete)通知)，当执行完毕后，这些值就会继续传给下一个处理器 订阅 只有 Observable 实例被订阅时，实例才会发布 订阅时需要先调用该实例的 subscribe() 方法，并把一个观察者对象传给它，用来接收通知 Observable 由一个构造函数可以创建新实例 下面使用 Observable 上定义的一些静态方法来爱创建一些常用的简单可观察对象： Observable.of(...items) -- 返回一个 Observable 实例，它用同步的方法把参数中提供的这些值发送出来 Observable.from(iterable) -- 把它的参数转换成一个 Observable 实例，该方法通常用于把一个数组转换成一个（发送多个值的）可观察对象 // 创建并订阅一个简单的可观察对象，它的观察者会把接收到的消息记录到控制台 // create simple observable that emits three values const myObservable = Observable.of(1,2,3); // create observer object const myObserver = { next: x => console.log('Observer got a next value: ' + x), error: err => console.log('Observer got an error:' + err), complete: () => console.log('Observer got a complete notification') }; // Execute with the observer object myObservable.subscribe(myObserver); // Logs: // Observer got a next value: 1 // Observer got a next value: 2 // Observer got a next value: 3 // Observer got a complete notificatio // subscribe() 方法还可以接收定义在统一行中的回调函数，无论 next、error 还是 complete 处理器，比如，下面的 subscribe() 调用和前面指定预订义观察者的例子时等价的 myObservable.subscribe( x => console.log('Observer got a next value: ' + x), err => console.error('Observer got an error: ' + err), () => console.log('Observer got a complete notification') ); next 处理器是必要的，而 error 和 complete 处理是可选的 next() 函数可以接收消息字符串、事件对象、数字值或各种结构，具体类型取决于上下文;可观察对象发布出来的数据统称为流 创建可观察对象 使用 Observable 构造函数可以创建任何类型的可观察流 执行可观察对象的 subscribe() 方法时，构造函数会把它接收到的参数作为订阅函数来运行，订阅函数会接收一个 Observer 对象，并把值发布给观察者的 next() 方法 // This function runs when subscribe() is called function sequenceSubscriber(observer) { // synchronously deliver 1, 2, and 3, then complete observer.next(1); observer.next(2); observer.next(3); observer.complete(); // unsubscribe function doesn't need to do anything in this // because values are delivered synchronously return {unsubscribe() {}}; } // Create a new Observable that will deliver the above sequence const sequence = new Observable(sequenceSubscriber); // execute the Observable and print the result of each notification sequence.subscribe({ next(num) { console.log(num); }, complete() { console.log('Finished sequence'); } }); // Logs: // 1 // 2 // 3 // Finished sequence 下面时一个加强例子，创建一个用来发布事件的可观察对象,订阅函数使用内联方式定义 // Create with custom fromEvent function function fromEvent(target, eventName){ return new Observable((observer) => { const handler = (e) => observer.next(e); // add the event handler to the target target.addEventListener(eventName, handler); return () => { // Detach the event handler from the target target.removeEventListener(eventName, handler); } }) } // use custom fromEvent function const ESC_KEY = 27; const nameInput = document.getElementById('name) as HTMLInputElement; const subscription = fromEvent(nameInput, 'keydown') .subscribe((e:keyboardEvent) => { if (e.keyCode === ESC_KEY) { nameInput.value = ''; } }) 多播 典型的可观察对象会为每一个观察者创建一次新的、独立的执行当观察者进行订阅时，该观察者对象会连上一个事件处理器，并且向那个观察者发送一些值；当第二个观察者订阅时，这个可观察对象就会连上上一个新的事件处理器，并独立执行一次，把这些值发送给第二个可观察对象 多播可以让观察者在一次执行中同时广播给多个订阅者，通过支持多播的可观察者对象，不用注册多个监听器，通过复用第一个(next)监听器，把值发给各个订阅者 function multicastSequenceSubscriber() { const seq = [1, 2, 3]; // Keep track of each observer (one for every active subscription) const observers = []; // Still a single timeoutId because there will only ever be one // set of values being generated, multicasted to each subscriber let timeoutId; // Return the subscriber function (runs when subscribe() // function is invoked) return (observer) => { observers.push(observer); // When this is the first subscription, start the sequence if (observers.length === 1) { timeoutId = doSequence({ next(val) { // Iterate through observers and notify all subscriptions observers.forEach(obs => obs.next(val)); }, complete() { // Notify all complete callbacks observers.slice(0).forEach(obs => obs.complete()); } }, seq, 0); } return { unsubscribe() { // Remove from the observers array so it's no longer notified observers.splice(observers.indexOf(observer), 1); // If there's no more listeners, do cleanup if (observers.length === 0) { clearTimeout(timeoutId); } } }; }; } // Run through an array of numbers, emitting one value // per second until it gets to the end of the array. function doSequence(observer, arr, idx) { return setTimeout(() => { observer.next(arr[idx]); if (idx === arr.length - 1) { observer.complete(); } else { doSequence(observer, arr, ++idx); } }, 1000); } // Create a new Observable that will deliver the above sequence const multicastSequence = new Observable(multicastSequenceSubscriber()); // Subscribe starts the clock, and begins to emit after 1 second multicastSequence.subscribe({ next(num) { console.log('1st subscribe: ' + num); }, complete() { console.log('1st sequence finished.'); } }); // After 1 1/2 seconds, subscribe again (should \"miss\" the first value). setTimeout(() => { multicastSequence.subscribe({ next(num) { console.log('2nd subscribe: ' + num); }, complete() { console.log('2nd sequence finished.'); } }); }, 1500); // Logs: // (at 1 second): 1st subscribe: 1 // (at 2 seconds): 1st subscribe: 2 // (at 2 seconds): 2nd subscribe: 2 // (at 3 seconds): 1st subscribe: 3 // (at 3 seconds): 1st sequence finished // (at 3 seconds): 2nd subscribe: 3 // (at 3 seconds): 2nd sequence finished 错误处理 因为可观察对象会异步生成值，所以 try/catch 无法捕获错误，因该在观察者中指定一个 error 回调来处理错误，发生错误时还会导致可观察对象清理现有的订阅，并且停止生成值;可观察对象可以生成值(调用next回调)，也可以调用 complete 或 error 回调来主动结束 myObservable.subscribe({ next(num) { console.log('Next num: ' + num)}, error(err) { console.log('Received an errror: ' + err)} }); RxJS 库 RxJS（响应式扩展的 JavaScript 版）是一个使用可观察对象进行响应式编程的库，RxJS 让组合异步代码和基于回调的代码变得更简单 RxJS 提供了一种对 Observable 类型的实现，直到 Observable 成为了 JavaScript 语言的一部分并且浏览器支持之前，它时由必要的，这个库还提供了一些工具函数，用于创建和使用可观察对象，这些工具可用于 把现有的异步代码转换为可观察对象 迭代流中的各个值 把这些值映射成其它类型 对流进行过流 组合多个流 创建可观察对象的函数 RxJS 提供了一些函数创建可观察对象，这些函数可以简化创建可观察对象的过程，比如事件、定时器、承诺等 // Create an observable from a promise import { fromPromise } from 'rxjs'; // create an Observable out of a promise const data = fromPormise(fetch('/api/endpoint')); //subscribe to begin listening for result data.subscribe({ next(response) {console.log(response);}, error(err) {console.log('Error:' + err);}, complete() {console.log('completed');} }); // create an observable from a counter import {interval} from 'rxjs'; // create an observable that will publish a value on an interval const secondsCounter = interval(1000); //subscribe to begin publishing values secondsCounter.subscribe(n => { console.log(`it's been ${n} seconds since subscribing!`); }); // create an observable from an event import {fromEvent} from 'rxjs'; const el = document.getElementById('my-element') // create an observable that publish mouse movemoments const mouseMoves = fromEvent(el, 'mousemove'); // subscribe to start listening for mouse-moev events const subscription = mouseMoves.subscribe((evt:MouseEvent) => { // log coords of mouse movements console.log(`coords: ${evt.clientX} X ${evt.clientY}`); }); // when the mouse is over the upper-left of the screen //unsubscribe to stop listening for mouse movements if(evt.clientX console.log(res.status, res.response)); 操作符 操作符时基于可观察对象构建的一些堆积和进行复杂操作的函数 RxJS 定义了一些操作符，如 map()、filter()、concat()、flatMap() 操作符接收一些配置项，然后返回一个以来源可观察对象为参数的函数，当执行这个返回的函数时，操作符会观察来源可观察对象中发出的值，转换它们，并返回由转换后的值组成的新的可观察对象 // map operator import { map } from 'rxjs/operators'; const nums = of(1, 2, 3); const squareValues = map((val: number) => val * val); const squaredNums = squareValues(nums); squaredNums.subscribe(x => console.log(x)); // Logs // 1 // 4 // 9 // 使用管道把操作符链接起来 import { filter, map } from 'rxjs/operators'; const nums = of(1, 2, 3, 4, 5); // Create a function that accepts an Observable. const squareOddVals = pipe( filter((n: number) => n % 2 !== 0), map(n => n * n) ); // 上面函数等价于下面函数，因为 pipe 函数也是 RxJS 的 observable 上的方法 const squareOdd = of(1, 2, 3, 4, 5) .pipe( filter(n => n % 2 !== 0), map(n => n * n) ); // Create an Observable that will run the filter and map functions const squareOdd = squareOddVals(nums); // Suscribe to run the combined functions squareOdd.subscribe(x => console.log(x)); 常用操作符 对 Angular 应用来说，推荐使用管道操作符，不推荐使用链式写法 常用操作符列表和用法如下表 操作符 操作 创建 from、fromPromise、fromEvent、of 组合 combineLatest、concat、merge、startWith、withLatestFrom、zip 过滤 dubounceTime、distinctUntilChanged、filter、take、takeUntil 转换 bufferTime、concatMap、map、mergeMap、scan、switchMap 工具 tap 多播 share 错误处理 error() (Observable)用于在订阅时进行错误处理 RxJS 提供 catchError 操作符，用于在管道中处理已知错误 import { ajax } from 'rxjs/ajax'; import { map, catchError } from 'rxjs/operators'; // Return \"response\" from the API. If an error happens, // return an empty array. const apiData = ajax('/api/data').pipe( map(res => { if (!res.response) { throw new Error('Value expected!'); } return res.response; }), // 此处时逗号 catchError(err => of([])) ); apiData.subscribe({ next(x) { console.log('data: ', x); }, error(err) { console.log('errors already caught... will not run'); } }); 重试失败的可观察对象 catchError 提供了一种简单的方式进行恢复 retry 操作符可以对对失败的请求进行重试 在 catchError 之前使用 retry 可以对失败的操作进行重新尝试 import { ajax } from 'rxjs/ajax'; import { map, retry, catchError } from 'rxjs/operators'; const apiData = ajax('/api/data').pipe( retry(3), // Retry up to 3 times before failing map(res => { if (!res.response) { throw new Error('Value expected!'); } return res.response; }), catchError(err => of([])) ); apiData.subscribe({ next(x) { console.log('data: ', x); }, error(err) { console.log('errors already caught... will not run'); } }); 可观察对象的命名约定 可观察对象的名字通常以\"$\"符号结尾 如果想用一个属性来存储可观察对象的最近一个值，该属性名字应该与可观察对象同名，但是不带\"$\"后缀 import { Component } from '@angular/core'; import { Observable } from 'rxjs'; @Component({ selector: 'app-stopwatch', templateUrl: './stopwatch.component.html' }) export class StopwatchComponent { stopwatchValue: number; stopwatchValue$: Observable; // 可观察对象名字以 $ 结尾 start() { this.stopwatchValue$.subscribe(num => this.stopwatchValue = num // 可观察对象值 ); } } Angular 中的可观察对象 可观察对象在 Angular 中用于处理各种常用的异步操作： EventEmitter 类派生自 Observable HTTP 模块使用可观察对象对象来处理 Ajax 请求响应 路由器和表单模块使用可观察对象来监听对用户输入事件的响应 事件发送器 EventEmitter Angular 提供了一个 EventEmitter 类，它用来从组件的 @Output() 属性中发布一些值 EventEmitter 扩展了 Observable，并添加了一个 emit() 方法，使得它可以发送任意值 调用 emit()时，EventEmitter 会把所发送的值传给订阅上来的观察者的 next() 方法 @Component({ selector: 'zippy', template: ` Toggle `}) export class ZippyComponent { visible = true; @Output() open = new EventEmitter(); @Output() close = new EventEmitter(); toggle() { this.visible = !this.visible; if (this.visible) { this.open.emit(null); } else { this.close.emit(null); } } } HTTP Angular 的 HttpClient 从 HTTP 方法调用中返回了可观察对象 http 返回可观察对象，先比 promise 有以下优点： 可观察对象不会修改服务器的响应(和在 promise 上串联起来的 .then() 调用一样)，但是，可以使用一系列操作符来按需转换这些值 HTTP 请求可以通过 unsubscribe() 方法来取消 请求可以进行配置，以获取进度事件的变化 失败的请求可以很简单的进行重试 Async 管道 AsyncPipe 会订阅一个可观察对象或承诺，并返回其发出的最后一个值，当发出新值时，该管道会把这个组建标记为需要进行变更的检查的(可能会导致刷新界面) // 把 time 这个可观察试图对象绑定到组件的试图中，可观察对象会不断使用当前事件更新组建的试图 @Component({ selector: 'async-observable-pipi', template: `observable|sync: Time: {{ time |async }} ` }) export class AsyncObservablePipeComponent { time = new Observable(observer => setInterval(() => observer.next(new Date().toString()), 1000) ) } 路由器 (router) Router.events 以可观察对象的形式提供了其事件 可以使用 RxJS 中的 filter() 操作符来找到感兴趣的事件，并订阅它们 ActivatedRoute 是一个可注入的路由器服务，使用可观察对象来获取关于路由器和路由参数的信息 // Router.events import { Router, NavigationStart } from '@angular/router'; import { filter } from 'rxjs/operators'; @Component({ selector: 'app-routable', templateUrl: './routable.component.html', styleUrls: ['./routable.component.css'] }) export class Routable1Component implements OnInit { navStart: Observable; constructor(private router: Router) { // Create a new Observable the publishes only the NavigationStart event this.navStart = router.events.pipe( filter(evt => evt instanceof NavigationStart) ) as Observable; } ngOnInit() { this.navStart.subscribe(evt => console.log('Navigation Started!')); } } // ActivateRoute.url 包含一个用于汇报路由路径的可观察对象 import { ActivatedRoute } from '@angular/router'; @Component({ selector: 'app-routable', templateUrl: './routable.component.html', styleUrls: ['./routable.component.css'] }) export class Routable2Component implements OnInit { constructor(private activatedRoute: ActivatedRoute) {} ngOnInit() { this.activatedRoute.url .subscribe(url => console.log('The URL changed to: ' + url)); } } 响应式表单(reactive forms) 响应式表单具有一些属性，它们使用可观察对象来监听表单控件的值 FormControl 的 valueChanges 属性和 statusChanges 属性包含了会发出变更事件的可观察对象 订阅可观察的表单控件属性时在组建类中触发应用逻辑的途径之一 import { FormGroup } from '@angular/forms'; @Component({ selector: 'my-component', template: 'MyComponent Template' }) export class MyComponent implements OnInit { nameChangeLog: string[] = []; heroForm: FormGroup; ngOnInit() { this.logNameChange(); } logNameChange() { const nameControl = this.heroForm.get('name'); nameControl.valueChanges.forEach( (value: string) => this.nameChangeLog.push(value) ); } } 用法实战 输入提示 (type-ahead) 建议 可观察对象可以简化输入提示建议的实现方式，典型的输入提示要完成一系列独立的任务： 从输入中监听数据 移除输入值前后的空白字符，并确认它达到了最小长度 防抖(防止连续按键时每次按键都发起 API 请求) 如果输入值没有变化，则不应该发起请求 如果已发出的 ajax 请求的结果会因为后续的修改而变得无效，应该取消它 import { fromEvent } from 'rxjs'; import { ajax } from 'rxjs/ajax'; import { map, filter, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators'; const searchBox = document.getElementById('search-box'); const typeahead = fromEvent(searchBox, 'input').pipe( map((e: KeyboardEvent) => e.target.value), filter(text => text.length > 2), debounceTime(10), distinctUntilChanged(), switchMap(() => ajax('/api/endpoint')) ); typeahead.subscribe(data => { // Handle the data from the API }); 指数化退避 指数化退避时一种失败后重试 API 的技巧，它会在每次连续的失败之后让重试时间逐渐变长，超过最大重试次数之后就会彻底放弃 import { pipe, range, timer, zip } from 'rxjs'; import { ajax } from 'rxjs/ajax'; import { retryWhen, map, mergeMap } from 'rxjs/operators'; function backoff(maxTries, ms) { return pipe( retryWhen(attempts => range(1, maxTries) .pipe( zip(attempts, (i) => i), map(i => i * i), mergeMap(i => timer(i * ms)) ) ) ); } ajax('/api/endpoint') .pipe(backoff(3, 250)) .subscribe(data => handleData(data)); function handleData(data) { // ... } 与其它技术的比较 可观察对象和 承诺(promise) 都用来处理异步操作 可观察对象vs.承诺 可观察对象是声明式的，在被订阅之前，不会开始执行;promise 在创建时就立即执行，因此可观察对象可以用于定义那些应该按需执行的菜谱 可观察对象能提供多个值，promise 只能提供一个 可观察对象会区分串联处理和订阅语句; promise 只有 then() 串联处理（await例外） 可观察对象与承诺实现同样功能接口对比如下 操作 可观察对象 promsie 创建 new Observable(observer) => {observer.next(123)} new Promise((resolve,reject) => {resolve(123)}) 转换 obs.map((value) => value*2) promise.then((value) => value *2) 订阅 sub = obs.subscribe((value) => {console.log(value)}) promsie.then((value) => console.log(value)) 取消订阅 sub.unsubscribbe() 承诺被解析时隐式完成 "},"Angular/knowledge/router.html":{"url":"Angular/knowledge/router.html","title":"router","keywords":"","body":"路由与导航 Angular 的路由器能让用户从一个试图导航到另一个试图 路由与导航 概览 基础知识 元素 从路由库中导入配置 配置 路由出口 路由链接 路由器状态 激活的路由 路由事件 小结 概览 基础知识 元素 传统的路由导航通过设置 href 值来设置路由路径 从路由库中导入配置 Angular 的路由器为一个可选服务，不是核心库的一部分，使用时需要引入 import { RouterModule, Routes } from '@angular/router' 配置 每个带路由的 Angular 应用都由一个 Router 服务的单例对象 当浏览器的 url 变化时，路由器查找对应的 Route，并显示相应的组件 路由器需要先配置才能使用 // src/app/app.module.ts const appRoutes: Routes = [ {path: 'crisis-center', component: CrisisListComponent}, {path : 'hero/:id', component: HeroDetailComponent}, { path: 'heroes', component: HeroListComponent, data: { title: 'Heroes List' } }, { path: '', redirectTo: '/heroes', pathMatch: 'full' }, { path: '**', component: PageNotFoundComponent } ]; @NgModule({ imports: [ RouterModule.forRoot( appRoutes, { enableTracing: true } // 上面的例子中，appRoutes定义了五个路由，用来描述如何进行导航，并用 RouterModule.foRoot 方法来配置路由器，并发返回值添加到 AppModule 的 imports 数组中 每个 Route 都会把一个 URL 的 path 映射到一个组建，path 不能以斜杠(/)开头，路由器会为解析和构建最终的 URL 第二个路由中的 :id 是一个路由参数的令牌(Token)，比如 /hero/42 这个 URL 中 \"42\"是 id 的参数，该 URL 对应的 HeroDetailComponent 组建将据此查找和展现 id 为 42 的英雄 第三个路由中的 data 用来存放每个具体路由有关的任意信息，该数据可以被任何一个激活路由访问，并能用来存放诸如页标题、面包屑以及其它静态只读数据 第四个路由中的空路径 ('') 表示应用的默认路径，当 URL 为空时就会访问哪里 第五个路由中的 ** 路径是一个通配符，当所有请求的 URL 不匹配前面定义的路由表中的任何路径时，路由器就会悬着此路由 把 enableTracing: true 选项作为第二个参数传给 RouterModule.forRoot() 方法可以把整个导航声明周期中的事件输出到浏览器的控制台，可以用于调试 路由出口 路由链接 通过给标签添加 routeLink 属性来控制导航跳转路径 template: ` Angular Router Crisis Center Heroes ` routerLinkActive 指令可以帮助用户在外观上区分出当前选中的“活动”路径 路由器状态 在导航时的每个生命周期成功完成时，路由器会构建出一个 ActivatedRoute 组成的树，它表示路由器的当前状态，可以在应用中的任何地发用 Router 服务及其 routerState 属性来访问当前的 RouterState 值 RouterState 中的每个 ActivatedRoute 都提供了从任意激活路由开始向上或向下遍历路由数的一种方式，以获得关于父、子、兄弟路由的信息 激活的路由 激活的路由的路径和参数可以通过注入进来的一个名叫 ActivatedRoute 的路由服务来获取，它由一大堆由用的信息，如下表: 属性 说明 url 路由路径的 Observable 对象，是一个由路由路径中的各个部分组成的字符串数组 data 一个 Observable，其中包含提供给路由的 data 对象，也包含由解析守卫(resolve guard)解析而来的值 paramsMap 一个 Observable,其中包含一个由当前路由的必要参数和可选参数组成的 map 对象，用这个 map 可以获取来自同名参数的单一值或多重值 queryParamMap 一个 Observable,其中包含一个对所有路由都有效的查询参数组成的 map 对象，用这个 map 可以获取来自查询参数的单一值或多重值 fragment 一个适用于所有路由的 URL 的 fragment(片段)的 Observable outlet 要把该路由渲染到的 RouterOutlet 的名字，对于无名路由，它的路由名是 primary，而不是空串 routeConfig 用于该路由的路由配置信息，其中包含原始路径 parent 当该路由是一个子路由时，表示该路由的父级 ActivatedRoute firstChild 包含该路径的子路由列表中的第一个 ActivatedRoute children 包含当前路由下所有已激活的子路由 路由事件 在每次导航周，Router 都会通过 Router.events 属性发布一些导航事件，这些事件的范围涵盖了从开始到导航结束之间的很多时间点，如下表： 路由器事件 说明 NavigationStart 在导航开始时触发 RoutesRecognized 在路由器解析完 URL,并识别出相应的路由时触发 RouteConfigLoadStart 在 Router 对一个路由配置进行惰性加载之前触发 RouteConfigLoadEnd 在路由被惰性加载之后触发 NavigationEnd 在导航成功结束之后触发 NavigationCancel 在导航被取消之后触发，可能是因为在导航期间某个路由守卫返回了 false NavigationError 在导航由于意外之外的错误而失败时触发 小结 对应用配置过一个路由器后，外壳组建中由一个 RouterOutlet，它能显示路由器所生成的试图，它还有一些 RouterLink，可以点击它们，来通过路由器进行导航 路由器中的关键词汇及其含义如下表: 路由器部件 含义 Router (路由器) 为激活的 URL 显示应用组件，管理从一个组建到另一个组建的导航 RouterModule 一个独立的 Angular 模块，用于提供多需的服务提供商，以及用来在应用视图之间进行导航的指令 Routes (路由数组) 定义了一个路由数组，每个都会把一个 URL 路径映射到一个组件 Route (路由)) 定义路由器该如何根据 URL 模式(pattern) 来导航到组建，大多数都由路径和组建类构成) RouterOutlet (路由出口) 指令 () 用来标记该路由器在哪里显示视图 RouterLink (路由链接) 这个指令把可点击的 HTML 元素绑定到某个路由。点击带有 routerLink 的元素时就会触发一次导航 RouterLinkActive （活动路由链接） 当 HTML 元素上或元素内的 routerLink 变为激活或非激活状态时，该指令为这个 HTML 元素添加或移除 CSS 类 ActivatedRoute (激活的路由) 为每个路由组件提供的一个服务，包含特定于路由的信息，比如路由参数、静态数据、解析数据、全局查询参数和全局碎片 (fragment) RouterState (路由器状态) 路由器的当前状态包括了一颗由程序中激活的路由构成的树，包含一些用于遍历路由树的快捷方法 链接参数数组 这个数组会被路由解析成一个路由操作指南。可以把一个 RouterLink 绑定到该数组，或者把它作为参数传给 Router.navigate 方法 路由组件 一个带有 RouterOutlet 的 Angular 组建，它根据路由器的导航来显示相应的视图 "},"Angular/knowledge/ngmodules/":{"url":"Angular/knowledge/ngmodules/","title":"Angular 模块","keywords":"","body":""},"Angular/knowledge/ngmodules/ngmodules.html":{"url":"Angular/knowledge/ngmodules/ngmodules.html","title":"NgModule 简介","keywords":"","body":" NgModule 简介 Angular 模块化 基本的模块 NgModule 简介 Angular 模块(NgModule) 用于配置注入器和编译器，并把相关的东西组织在一起 NgModule 是一个带有 @NgModule 修饰器的类，@NgModule 的参数时一个元数据对象，用来描述如何编译组件的模板，以及如何在运行时创建注入器 NgModule 会标出该模块自己的组件、指令、管道，通过 exports 属性公开其中的一部分，让外部组件使用 NgModule 还能把一些服务提供商添加到应用的以来注入器 Angular 模块化 模块化是组织应用和使用外部库扩展应用的最佳途径 Angular 自己的库都是 NgModule，如 FromsModule、HttpClientModule 和 RouterModule；很多第三方库也是 NgModule，如：Material Design、Ionic、AngularFire2 Angular 模块把组件、指令、管道打包成内聚的功能块，每个模块聚焦于一个特性区域、业务区域、工作流或通用工具 模块还可以把服务添加到应用中，服务可以时自己编写的或来自于外部(Angular 的路由和 HTTP 客户端)) 模块可以在应用启动时立即加载，也可以由路哟偶器进行异步的惰性加载 NgModule 的元数据会做下面的事情: 声明某些组件、指令和管道属于这个模块 暴露其中的部分组件、指令和管道，让其它模块中的组件模板可以使用 导入其它带有组件、指令和管道的模块供本组件使用 提供一些供应用中的其它组建使用的服务 每个 Angular 应用至少由一个模块，即根模块;通过引导根模块来启动该应用 基本的模块 CLI 在创建新应用时会生成下列基本的应用模块 // imports import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { FormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; import { ItemDirective } from './item.directive'; // NgModule配置 // @NgModule decorator with its metadata @NgModule({ declarations: [ // 指令 AppComponent, ItemDirective ], imports: [ // 使用了哪些模块 BrowserModule, FormsModule, HttpClientModule ], providers: [], // 服务提供商 bootstrap: [AppComponent] // 启动组件(根模块) }) export class AppModule { } "},"Angular/knowledge/ngmodules/ngmodule-vs-jsmodule.html":{"url":"Angular/knowledge/ngmodules/ngmodule-vs-jsmodule.html","title":"JS 模块 vs NgModule","keywords":"","body":" JS 模块 vs NgModule JS Module NgModules NgModule 类与 JS 模块对比 JS 模块 vs NgModule Angular 应用同时依赖 JS Module 和 NgModule JS Module 在 JS 中，模块是内含 JS 代码的独立文件，要让其能够被使用，需要导出该模块 // export js module export class AppComponent { ... } // import js module import { AppComponent } from './app.component'; NgModules NgModule 是一些(不是一个)带有 @NgModule 修饰器的类 NgModule 修饰器的 imports 数组表示哪些 NgModule 是当前 Angular 应用多需要的，imports 数组中的模块是 NgModule 而不是 JS Module; 带有 @NgModule 修饰器的类通常会习惯性的放在单独的文件中，因为带有 @NgModule 修饰器和元数据，用户区分 Angular CLI 生成的 AppModule 如下： /* These are JavaScript import statements. Angular doesn’t know anything about these. */ import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; /* The @NgModule decorator lets Angular know that this is an NgModule. */ @NgModule({ declarations: [ AppComponent ], imports: [ /* These are NgModule imports. */ BrowserModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } NgModule 类与 JS 模块对比 Angular 模块只绑定了可声明的类，这些可声明的类只是供 Angular 编译器用的 与 JS 类把它所有的成员类都放在一个巨型文件中不同，NgModule 需要把该模块的类列在它的 @NgModule.declarations 列表中 Angular 模块只能导出可声明的类，这可能时它自己拥有的也可能时从其它模块中导入的，它不会声明或导出其它类型的类 与 JS 模块不同，NgModule 可以通过把服务提供商加到 @NgModule.providers 列表中，来用服务扩展整个应用 "},"Angular/knowledge/ngmodules/frequent-ngmodules.html":{"url":"Angular/knowledge/ngmodules/frequent-ngmodules.html","title":"常用模块","keywords":"","body":" 常用模块 导入模块 BrowserModule 和 CommonModule 常用模块 Angular 应用需要不止一个模块，但是它们都为根模块服务 要实现某些特性，可以添加响应的模块来实现 NgModule 导入自 为何使用 BrowserModule @angular/platfrom-browser 当你想要在浏览器中运行应用时 CommonModule @angular/common 当你想要使用 NgIf 和 NgFor 时 FormsModule @angular/forms 当要构建模板驱动表单时 (它包含 NgModule) ReactiveFormsModule @angular/froms 当要构建响应式表单时 RouterModule @angular/router 当要使用和路由相关服务时 HttpClientModule @angular/common/http 当要和服务对话时 导入模块 使用 Angular 模块时，需要在 AppModule 中导入它们，并把它们列在当前 @NgModule 的imports 数组中 /* import modules so that AppModule can access them */ import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; @NgModule({ declarations: [ AppComponent ], imports: [ /* add modules here so Angular knows to use them */ BrowserModule, ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } BrowserModule 和 CommonModule BrowserModule 导入了 CommonModule，它贡献了很多通用指令，如 ngIf 和 ngFor BrowserModule 重新导出了 CommonModule，以便它所有的指令在任何导入了 browserModule 的 Angular 模块中都可以使用 如果应用运行在浏览器中，必须在根模块 AppModule 导入 BrowserModule 如果把 BrowserModule 导入了惰性加载的特性模块中，Angular 会返回一个错误，并告诉你应该改用 CommonModule "},"Angular/knowledge/ngmodules/module-types.html":{"url":"Angular/knowledge/ngmodules/module-types.html","title":"特性模块的分类","keywords":"","body":"特性模块的分类 模块特性有五个常用分类 领域特性模块 带路由的特性模块 路由模块 服务特性模块 可视不见特性模块 模块特性每种类型的使用及其典型特征，实际使用中可以混合，如下表 特性模块 指导原则 领域 领域特性模块用来给用户提供应用程序领域中他有的用户体验，比如编辑客户信息或下订单等. 它们通常会有一个顶级组件来充当该特性的根组件，并且通常是私有的，用来支持它的各级子组件. 领域特性模块大部分由 declarations 组成，只有顶级组件会被导出. 领域特性模块很少会有服务提供商，如果有，哪么这些服务的生命周期必须和该模块的生命周期完全相同. 领域特性模块通常会由更高一级的特性模块导出且只能导出一次. 对于缺少路由的小型应用，它们可能只会被根模块 AppModule 导入一次 路由 带路由的特性模块是一种特殊的领域特性模块，但它的顶层组件会作为路由导航时的目标组件. 根据这个定义，所有惰性加载的模块都是路由特性模块. 带路由的特性模块不会带出任何东西，因为它们的组件永远不会出现在外部组件的模版中. 惰性假造的路由特性模块必须被其它模块导入，如果那样做就会导致它被立即加载，破坏了惰性加载的设计用途，也就是说你应该永远不会看到它们在 AppModule 的 imports 中被引用，立即加载的路由特性模块很少会被其它模块导入，以便编译器能了解它所包含的组件. 路由特性模块很好会有服务提供商，因为如果那样，那么它所提供的服务的生命周期必须与该模块的声明周期完全相同，不要在路由特性模块或被路由特性模块所导入的模块中提供全应用级的单例服务 路由 路由模块为其它模块提供路由配置，并且版路由这个关注点从它的配置模块中分离出来，路由模块通常会做下面一些事情： 1.定义路由 2.把路由配置添加到该模块的 imports 中 3.把路由守卫和解析器的服务提供商添加 到该模块的 providers 中 4.路由模块应该与其配套模块同名，但是加上 Routing 后缀，比如，foo.module.ts 中的 FooModule 就有一个位于 foo-routing.module.ts 文件中 FooRoutingModule 路由模块，如果其配套模块是根模块 AppModule, AppRoutingModule 就要使用 RouterModule.forRoot(routes) 来把路由器配置添加到它的 imports 中，所有其它路由模块都是子模块，要使用 RouterModule.forChild(routes) 5.按照惯例，路由模块后重新导出这个 RouterModule，以便其配套模块中的组件可以访问路由器指令，比如 RouterLink 和 RouterOutlet 路由模块值应该被它的配套模块导入 窗口部件 窗口不见模块为外部模块提供组件、指令、管道，很多第三方 UI组件库都是窗口不见模块 窗口部件模块应该完全由可声明对象组成，它们中的大部分都应该被导出 窗口不见模块很少会有服务提供商 如果任何模块的组件模块中需要用到这些窗口部件，就请导入响应的窗口部件模块 下表为各种特性模块类型的关键特征 特性模块 声明 declarations 提供商 providers 导出什么 被谁导入 领域 有 罕见 顶级组件 特性模块，AppModule 路由 有 罕见 无 无 路由 无 是（守卫） RouterModule 特性（供路由使用） 服务 无 有 无 AppModule 窗口部件 有 罕见 有 特性 "},"Angular/knowledge/ngmodules/entry-components.html":{"url":"Angular/knowledge/ngmodules/entry-components.html","title":"入口文件","keywords":"","body":"入口文件 入口文件 引导用的入口组件 路由到入口组件 entryComponents 数组 entryComponents 和编译器 从分类上来说，入口组件是 Angular 命令式加载的任意组件(也就是说你没有在模块中引种过它)，你可以在 NgModule 中引导它，或把它包含在路由中来指定入口组件 组件被包含在模版中，它们是声明式的 组件不是被包含在模版中，使用命令式加载它，这就是入口组件 入口组件有两种主要类型 引导用的根组件 在路由定义中指定的组件 引导用的入口组件 可引导组件是一个入口组件，Angular 会在引导过程中把它加载到 DOM 中，其它入口组件是在其它时机动态加载的，比如路由器 引导用的组件必须是入口组件，因为引导过程是命令式的，所以它需要一个入口组件 // 指定一个引导用组件 AppComponent @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, FormsModule, HttpModule, AppRoutingModule ], providers: [], bootstrap: [AppComponent] // bootstrapped entry component }) Angular 会动态加载根组件 AppComponent，因为它的类型作为参数传给了 @NgModule.bootstrap 函数 路由到入口组件 入口组件的第二种类型出现在路由定义中 所有的路由组件都必须是入口组件 const routes: Routes = [ { path: '', component: CustomerListComponent } ]; entryComponents 数组 @NgModule 修饰器具有一个 entryComponents 数组，大多数情况下你不用显示设置入口组件，因为 Angular 会自动把 @ngModule.bootstrap 中的组件以及路由定义中的组件添加到入口组件中 entryComponents 和编译器 Angular 编译器只会为那些可以从 entryComponents 中直接或间接访问到的组件生成代码 "},"Angular/knowledge/ngmodules/feature-modules.html":{"url":"Angular/knowledge/ngmodules/feature-modules.html","title":"特性模块","keywords":"","body":"特性模块 特性模块是用来对代码进行组织的模块 特性模块 特性模块vs根模块 如何制作特性模块 导入特性模块 渲染特性模块的组件模板 特性模块vs根模块 特性模块时最佳的组织方式 特性模块提供了聚焦于特定应用需求的一组功能，比如用户工作流、路由或表单 通过特性模块把应用划分成一些聚焦的功能区让服务便于管理 如何制作特性模块 通过 CLI 命令生成 ng g module CustomerDashboard : 在当前目录创建一个名为 customer-dashboard 的文件夹，文件夹下有一个名为 customer-dashboard.module.ts的文件 ng g component customer-dashboard/CustomerDashboard ：在 customer-dashboard 目录下创建一个名为 customer-dashboard 的组件 // module-name.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [ CommonModule ], declarations: [] }) export class CustomerDashboardModule { } // 暴露特性模块 // import the new component import { CustomerDashboardComponent } from './customer-dashboard/customer-dashboard.component'; @NgModule({ imports: [ CommonModule ], declarations: [ CustomerDashboardComponent ], }) 无论是根模块还是特性模块，其 NgModule 结构都时一样的 特性模块导入 CommonModule，而不是 BrowserModule，BrowserModule 只应该在根模块中导入一次 declarations 数组用于添加这个模块的可声明对象(组件、指令、管道) 导入特性模块 把特性模块添加到 AppModule 中即导入该特性模块 import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { FormsModule } from '@angular/forms'; import { HttpModule } from '@angular/http'; import { AppComponent } from './app.component'; // import the feature module here so you can add it to the imports array below import { CustomerDashboardModule } from './customer-dashboard/customer-dashboard.module'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, FormsModule, HttpModule, CustomerDashboardModule // add the feature module here ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } 如果你往该特性模块中加入任何服务商，AppModule 也同样会知道 渲染特性模块的组件模板 在 declarations 数组的下方，添加一个 exports 数组，并加入当前模块名字 然后在 AppComponent 的 app.component.html 中加入标签 // app/customer-dashboard/customer-dashboard.module.ts @NgModule({ imports: [ CommonModule ], declarations: [ CustomerDashboardComponent ], exports: [ // 添加到处模块 CustomerDashboardComponent ] }) {{title}} "},"Angular/knowledge/ngmodules/providers.html":{"url":"Angular/knowledge/ngmodules/providers.html","title":"服务提供商","keywords":"","body":"服务提供商 服务提供商相当于说明书，用来指导 DI 系统该如何获取某个依赖的值，大多数情况下，这些依赖就是你要创建和提供的那些服务 提供服务 import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root', // 指定该服务应该在根注入器中提供 }) export class UserService { } 修饰器 @Injectable 用 providerIn 属性进行配置，它会为该服务创建一个提供商 提供商作用域 如果把服务提供商添加到应用的根注入器中，它就能在整个应用程序中被使用，同时，这些服务提供商也同样对整个应用中的类是可用的(如果有服务令牌) 应该始终在根注入器中提供这些服务 providedIn 与 NgModule "},"Angular/knowledge/ngmodules/singleton-services.html":{"url":"Angular/knowledge/ngmodules/singleton-services.html","title":"单例应用","keywords":"","body":"单例应用 "},"Angular/knowledge/component&template/":{"url":"Angular/knowledge/component&template/","title":"组件与模版","keywords":"","body":" 组件与模板 显示数组 模板语法 生命周期钩子 组件交互 组件样式 Angular 自定义元素 动态组件 属性型组件指令 结构型指令 管道 动画 "},"Angular/knowledge/component&template/lifecycle-hooks.html":{"url":"Angular/knowledge/component&template/lifecycle-hooks.html","title":"生命周期钩子","keywords":"","body":"生命周期钩子 生命周期钩子 组件生命周期钩子概览 生命周期的顺序 接口时可选的（严格来说） 其它生命周期钩子 生命周期范例 Peek-a-boo:全部钩子 OnInit() 和 OnDestory 钩子 OnInit() 钩子 OnDestory() 钩子 OnChanges() 钩子 DoCheck() 钩子 AfterView 钩子 AfterContent 钩子 组件生命周期钩子概览 指令和组件的实例有一个生命周期：新建、更新、销毁 通过实现一个或多个 Angular core 库里定义的生命周期钩子接口，开发者可以介入该生命周期中的这些关键时刻 每个接口都有唯一的一个钩子方法，它们的名字是由接口名再加上 ng 前缀构成的 只有在指令/组件中定义过的钩子方法才会被 Angualr 调用 // OnInit 接口的钩子方法叫做 ngOnInit， Angular 在创建组件后立刻调用它 export class PeekABoo implements OnInit { constructor(private logger: LoggerService) {} // implement OnInit's `ngOnInit` method ngOnInit() { this.logIt(`OnInit`); } logIt(msg: string) { this.logger.log(`#${nextId++} ${msg}`); } } 生命周期的顺序 当 Angualr 使用构造函数新建一个组件或指令后，会按顺序在特定时刻调用生命周期钩子方法 钩子 用途及时机 ngOnchanges() 当 Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的 SimpleChanges 对象 当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在 ngOnInit() 之前 ngOnInit() 在 Angular 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件 在第一轮 ngOnChanges() 完成之后调用，只调用一次 ngDoCheck() 检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应 在每个 Angular 变更检测周期中调用 ngAfterContentInit() 当把内容投影进组件之后调用 第一次 ngDoCheck() 之后调用，只调用一次 ngAfterContentChecked() 每次完成被投影组件内容的变更检测之后调用 ngAfterContentInit() 和每次 ngDoCheck() 之后调用 ngAfterViewInit() 初始化完组件视图及其子视图之后调用 第一次 ngAfterContentChecked() 之后调用，只调用一次 ngAfterViewChecked() 每次做完组件视图和子视图的变更检测之后调用 ngAfterViewInit() 和每次 ngAfterContentChecked() 之后调用 ngOnDestory() 当 Angular 每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏 在 Angular 销毁指令/组件之前调用 接口时可选的（严格来说） 生命周期钩子接口函数时可选的，只有定义了才会执行 其它生命周期钩子 Angular 子系统可以有子集的生命周期钩子 第三方库也可以有子集的钩子 生命周期范例 Peek-a-boo:全部钩子 OnInit() 和 OnDestory 钩子 OnInit() 钩子 执行 OnInit() 时，属性已经被正常赋值 OnDestory() 钩子 在组件消失之前调用 OnChanges() 钩子 检测到组件(或指令)的输入属性发生了变化，会执行 DoCheck() 钩子 检测 Angular 自身无法捕获的变更并采取行动 AfterView 钩子 在每次创建了子组建的子视图后调用 AfterContent 钩子 在外来内容被投影到组件中之后调用它们 "},"Angular/knowledge/component&template/component-interaction.html":{"url":"Angular/knowledge/component&template/component-interaction.html","title":"组件交互","keywords":"","body":"组件交互 组件交互 通过输入型绑定把数据从父组件传入到子组件 通过 setter 截听输入属性值的变化 通过 ngOnChange()来截听输入属性值的变化 父组件监听子组件的事件 父组件与子组件通过本地变量互动 父组件调用 @ViewChild() 父组件和子组件通过服务来通讯 通过输入型绑定把数据从父组件传入到子组件 子组件 // app/hero-child.component.ts import { Component, Input } from \"@angular/core\"; import { Hero } from \"./hero\"; @Component({ selector: \"app-hero-child\", template: ` {{hero.name}} says: I, {{hero.name}}, am at your service, {{masterName}}. ` }) export class HeroChildComponent { @Input() hero: Hero; @Input(\"master\") masterName: string; // master 为别名，不建议 } 父组件 // app/hero-parent.component.ts import { Component } from \"@angular/core\"; import { HEROES } from \"./hero\"; @Component({ selector: \"app-hero-parent\", template: ` {{master}} controls {{heroes.length}} heroes ` }) export class HeroParentComponent { heroes = HEROES; master = \"Master\"; } 父组件 HeroParentComponent 把子组件的 HeroChildComponent 放到 *ngFor 循环器中，把自己的 master 字符串属性绑定到子组件的 master 别名上，并把每个循环的 hero 实例绑定到子组件的 hero 属性 Back TO TOC 通过 setter 截听输入属性值的变化 使用一个输入属性的 setter，以拦截父组件中值的变化，并才去行动 子组件 import { Component, Input } from \"@angular/core\"; @Component({ selector: \"app-name-child\", template: '\"{{name}}\"' }) export class NameChildComponent { private _name = \"\"; @Input() set name(name: string) { this._name = (name && name.trim()) || \"\"; } get name(): string { return this._name; } } 父组件 import { Component } from \"@angular/core\"; @Component({ selector: \"app-name-parent\", template: ` Master controls {{names.length}} names ` }) export class NameParentComponent { // Displays 'Mr. IQ', '', 'Bombasto' names = [\"Mr. IQ\", \" \", \" Bombasto \"]; } 子组件 NameChildComponent 的输入属性 name 上的这个 setter，会 trim 掉名字里的空格，并把空值替换成默认字符串 Back TO TOC 通过 ngOnChange()来截听输入属性值的变化 使用 OnChanges 生命周期钩子接口的 ngChanges() 方法来监测输入属性值的变化并作出回应 当需要检测多个、交互式输入属性的时候，本方法比用属性的 setter 更合适 子组件 import { Component, Input, OnChanges, SimpleChange } from \"@angular/core\"; @Component({ selector: \"app-version-child\", template: ` Version {{major}}.{{minor}} Change log: {{change}} ` }) export class VersionChildComponent implements OnChanges { @Input() major: number; @Input() minor: number; changeLog: string[] = []; ngOnChanges(changes: { [propKey: string]: SimpleChange }) { let log: string[] = []; for (let propName in changes) { let changedProp = changes[propName]; let to = JSON.stringify(changedProp.currentValue); if (changedProp.isFirstChange()) { log.push(`Initial value of ${propName} set to ${to}`); } else { let from = JSON.stringify(changedProp.previousValue); log.push(`${propName} changed from ${from} to ${to}`); } } this.changeLog.push(log.join(\", \")); } } 父组件 import { Component } from \"@angular/core\"; @Component({ selector: \"app-version-parent\", template: ` Source code version New minor version New major version ` }) export class VersionParentComponent { major = 1; minor = 23; newMinor() { this.minor++; } newMajor() { this.major++; this.minor = 0; } } VersionChildComponent 会监测输入属性 major 和 minor 的变化，并把这些变化编写成日志以报告这些变化。VersionParentComponent 提供 minor 和 major 值，把修改它们值的方法绑定到按钮上 Back TO TOC 父组件监听子组件的事件 子组件暴露一个 EventEmitter 属性，当事件发生时，子组件利用该属性 emits(向上弹射)事件。父组件绑定到这个事件属性，并在事件发生时作出回应 框架(Angular)把事件参数(用 $event 表示)传给事件处理方法，这个方法会处理 子组件 // 子组件的 EventEmitter 属性是一个输出属性，通常带有@Output 装饰器，就像在 VoterComponent 中看到的 // 点击按钮会触发 true 或 false(布尔型有效载荷)的事件 import { Component, EventEmitter, Input, Output } from \"@angular/core\"; @Component({ selector: \"app-voter\", template: ` {{name}} Agree Disagree ` }) export class VoterComponent { @Input() name: string; @Output() voted = new EventEmitter(); didVote = false; vote(agreed: boolean) { this.voted.emit(agreed); this.didVote = true; } } 父组件 // 父组件 VoteTakerComponent 绑定了一个事件处理器(onVoted())，用来响应子组件的事件($event)并更新一个计数器 import { Component } from \"@angular/core\"; @Component({ selector: \"app-vote-taker\", template: ` Should mankind colonize the Universe? Agree: {{agreed}}, Disagree: {{disagreed}} ` }) export class VoteTakerComponent { agreed = 0; disagreed = 0; voters = [\"Mr. IQ\", \"Ms. Universe\", \"Bombasto\"]; onVoted(agreed: boolean) { agreed ? this.agreed++ : this.disagreed++; } } Back TO TOC 父组件与子组件通过本地变量互动 父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法。但可以在父组件模板里，新建一个本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法 子组件 // 子组件 CountdownTimerComponent 进行倒计时，归零时发射一个导弹。start 和 stop 方法负责控制时钟并在模板里显示倒计时的状态信息 import { Component, OnDestroy, OnInit } from \"@angular/core\"; @Component({ selector: \"app-countdown-timer\", template: \"{{message}}\" }) export class CountdownTimerComponent implements OnInit, OnDestroy { intervalId = 0; message = \"\"; seconds = 11; clearTimer() { clearInterval(this.intervalId); } ngOnInit() { this.start(); } ngOnDestroy() { this.clearTimer(); } start() { this.countDown(); } stop() { this.clearTimer(); this.message = `Holding at T-${this.seconds} seconds`; } private countDown() { this.clearTimer(); this.intervalId = window.setInterval(() => { this.seconds -= 1; if (this.seconds === 0) { this.message = \"Blast off!\"; } else { if (this.seconds 父组件 import { Component } from \"@angular/core\"; import { CountdownTimerComponent } from \"./countdown-timer.component\"; @Component({ selector: \"app-countdown-parent-lv\", template: ` Countdown to Liftoff (via local variable) Start Stop {{timer.seconds}} `, styleUrls: [\"../assets/demo.css\"] }) export class CountdownLocalVarParentComponent {} 父组件不能通过数据绑定使用子组件的 start 和 stop 方法，也不能访问子组件的 seconds 属性。 把本地变量(#timer)放到()标签中，用来代表子组件。这样父组件的模板就得到了子组件的引用，于是可以在父组件的模板中访问子组件的所有属性和方法。 这个例子把父组件的按钮绑定到子组件的 start 和 stop 方法，并用插值表达式来显示子组件的 seconds 属性。 Back TO TOC 父组件调用 @ViewChild() 当父组件需要读取子组件的属性值或调用子组件的方法，可以把子组件作为 ViewChild，注入到父组件里面 父组件 import { AfterViewInit, ViewChild } from \"@angular/core\"; import { Component } from \"@angular/core\"; import { CountdownTimerComponent } from \"./countdown-timer.component\"; @Component({ selector: \"app-countdown-parent-vc\", template: ` Countdown to Liftoff (via ViewChild) Start Stop {{ seconds() }} `, styleUrls: [\"../assets/demo.css\"] }) export class CountdownViewChildParentComponent implements AfterViewInit { @ViewChild(CountdownTimerComponent) private timerComponent: CountdownTimerComponent; seconds() { return 0; } ngAfterViewInit() { // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ... // but wait a tick first to avoid one-time devMode // unidirectional-data-flow-violation error setTimeout(() => (this.seconds = () => this.timerComponent.seconds), 0); } start() { this.timerComponent.start(); } stop() { this.timerComponent.stop(); } } 子组件视图插入到服组件类步骤 ViewChild 装饰器导入这个引用，并挂上 AfterViewInit 生命周期钩子 通过 @ViewChild 属性装饰器，将子组件 CountdownTimerComponent 注入到私有属性 timerComponent 里面 ngAfterViewInit() 生命周期钩子是非常重要的一步。被注入的计时器组件只有在 Angular 显示了父组件视图之后才能访问 Back TO TOC 父组件和子组件通过服务来通讯 父组件和它的子组件共享一个服务，利用该服务在家庭内部实现双向通讯 该服务实例的作用域被限制在父组件和其子组件内，这个组件树之外的组件将无法访问改服务或者与它们通信 服务 这个 MissionService 把 MissionControlComponent 和多个 AstronautComponent 子组件连接起来 import { Injectable } from \"@angular/core\"; import { Subject } from \"rxjs\"; @Injectable() export class MissionService { // Observable string sources private missionAnnouncedSource = new Subject(); private missionConfirmedSource = new Subject(); // Observable string streams missionAnnounced$ = this.missionAnnouncedSource.asObservable(); missionConfirmed$ = this.missionConfirmedSource.asObservable(); // Service message commands announceMission(mission: string) { this.missionAnnouncedSource.next(mission); } confirmMission(astronaut: string) { this.missionConfirmedSource.next(astronaut); } } 父组件 MissionControlComponent 提供服务的实例，并将其共享给它的子组件(通过 providers 元数据数组)，子组件可以通过构造函数将该实例注入到自身 import { Component } from \"@angular/core\"; import { MissionService } from \"./mission.service\"; @Component({ selector: \"app-mission-control\", template: ` Mission Control Announce mission History {{event}} `, providers: [MissionService] }) export class MissionControlComponent { astronauts = [\"Lovell\", \"Swigert\", \"Haise\"]; history: string[] = []; missions = [\"Fly to the moon!\", \"Fly to mars!\", \"Fly to Vegas!\"]; nextMission = 0; constructor(private missionService: MissionService) { missionService.missionConfirmed$.subscribe(astronaut => { this.history.push(`${astronaut} confirmed the mission`); }); } announce() { let mission = this.missions[this.nextMission++]; this.missionService.announceMission(mission); this.history.push(`Mission \"${mission}\" announced`); if (this.nextMission >= this.missions.length) { this.nextMission = 0; } } } 子组件 AstronautComponent 也通过自己的构造函数注入该服务。由于每个 AstronautComponent 都是 MissionControlComponent 的子组件，所以它们获取到的也是父组件的这个服务实例 import { Component, Input, OnDestroy } from \"@angular/core\"; import { MissionService } from \"./mission.service\"; import { Subscription } from \"rxjs\"; @Component({ selector: \"app-astronaut\", template: ` {{astronaut}}: {{mission}} Confirm ` }) export class AstronautComponent implements OnDestroy { @Input() astronaut: string; mission = \"\"; confirmed = false; announced = false; subscription: Subscription; constructor(private missionService: MissionService) { this.subscription = missionService.missionAnnounced$.subscribe(mission => { this.mission = mission; this.announced = true; this.confirmed = false; }); } confirm() { this.confirmed = true; this.missionService.confirmMission(this.astronaut); } ngOnDestroy() { // prevent memory leak when component destroyed this.subscription.unsubscribe(); } } Back TO TOC "},"Angular/knowledge/component&template/component-styles.html":{"url":"Angular/knowledge/component&template/component-styles.html","title":"组件样式","keywords":"","body":"组件样式 Angular 使用标准的 CSS来这只样式 Angualr 还能把组件样式捆绑在组件上 组件样式 使用组件样式 范围化的样式 特殊的选择器 :host 选择器 :host-context 选择器 已废弃/deep/、>>>、::ng-deep 把样式加载进数组中 元数据中的样式 组件元数据中的样式文件 模版内联样式 模板中的 link 标签 CSS@imports 语法 外部以及全局样式文件 非 CSS 样式文件 控制视图的封装模式:原生(Native)、仿真(Emulated)、无(None) 查看仿真(Emulated)模式下生成的 CSS 使用组件样式 在组员的元数据中设置 styles 属性 styles 属性可以接受一个包含 CSS 代码的字符串数组，注意：styles 值时字符串数组 @Component({ selector: 'app-root', template: ` Tour of Heroes `, styles: ['h1 { font-weight: normal; }'] }) export class HeroAppComponent { /* . . . */ } Back TO TOC 范围化的样式(组件样式) 在 @Component 的元数据中指定的样式只会对改组件的模板生效 范围化样式既不会被模板中嵌入的组件继承，也不会被通过内容投影(如:ng-content)嵌进来的组件集成 范围化样式特性 可以使用对每个组件最有意义的 CSS 类名和选择器 类名和选择器时仅属于组件内部的，不会和应用中其它地方的类名和选择器出现冲突 组件的样式不会因为别的地方修改了样式而被意外修改 可以让每个组件的 CSS 代码和它的 TS、HTML 代码放在一起，促成清爽整洁的目录结构 修改或移除组件的 CSS 代码，不会对其它组件造成影响 Back TO TOC 特殊的选择器 从影子(Shadow) DOM 样式范围领域引入的特殊选择器 Back TO TOC :host 选择器 选择宿主元素中的元素(相对组件模板内部的元素) :host { display: block; border: 1px solid black; } /* 把宿主元素作为目标，但是只有当它同时带有 active CSS 类的时候才会生效 */ :host(.active) { border-width: 3px; } Back TO TOC :host-context 选择器 Back TO TOC 已废弃/deep/、>>>、::ng-deep Back TO TOC 把样式加载进数组中 有三种方式把样式加入组件 设置 styles 或 styleUrls 元数据 内联在模板 HTML 中 通过 CSS 文件导入 Back TO TOC 元数据中的样式 给 @Component 装饰器添加一个 styles 数组型属性 这个数组中的每一个字符串（通常也只有一个）定义一份 CSS 样式只对当前组件生效，不会作用域模板中嵌入的组件，也不会作用与投影进来的组件 @Component({ selector: 'app-root', template: ` Tour of Heroes `, styles: ['h1 { font-weight: normal; }'] }) export class HeroAppComponent { /* . . . */ } 使用 --inline-styles 标识创建组件时，cli 会定义一个空的 styles 数组 ng generate component hero-app --inline-style Back TO TOC 组件元数据中的样式文件 把外部 CSS 文件添加到 @Component 的 styleUrls 属性中来加载外部样式 样式只对当前组件生效，不会作用域模板中嵌入的组件，也不会作用与投影进来的组件 可以指定多个样式文件，甚至可以组合使用 style 和 styleUrls 方式 @Component({ selector: 'app-root', template: ` Tour of Heroes `, styleUrls: ['./hero-app.component.css'] }) export class HeroAppComponent { /* . . . */ } /* hero-app.component.css */ h1 { font-weight: normal; } Back TO TOC 模版内联样式 在组件的 HTML 模板中嵌入 标签 @Component({ selector: 'app-hero-controls', template: ` button { background-color: white; border: 1px solid #777; } Controls Activate ` }) Back TO TOC 模板中的 link 标签 在组件的 HTML 模板中写 标签 使用 CLI 进行构建时，要确保这个链接到的样式表文件被复制到了服务器上。参见 @Component({ selector: 'app-hero-team', template: ` Team {{member}} ` }) Back TO TOC CSS@imports 语法 利用标准的 CSS @import 规则来把其它 CSS 文件导入到 CSS 文件中 URL 是相对于你正在导入的 CSS 文件的 /* The AOT compiler needs the `./` to show that this is local */ @import './hero-details-box.css'; Back TO TOC 外部以及全局样式文件 当使用 CLI 进行构建时，你必须配置 angular.json 文件，使其包含所有外部资源 在它的 styles 区注册这些全局样式文件，默认情况下，它会有一个预先配置的全局 styles.css 文件 { \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\", \"version\": 1, \"newProjectRoot\": \"projects\", \"projects\": { \"angular-tour-of-heroes\": { \"architect\": { \"build\": { ... \"styles\": [ \"src/styles.css\" ], \"scripts\": [] } }, \"test\": { \"builder\": \"@angular-devkit/build-angular:karma\", \"options\": { \"styles\": [ \"src/styles.css\" ] ... } }, } } }, \"defaultProject\": \"angular-tour-of-heroes\" } Back TO TOC 非 CSS 样式文件 使用 CLI 进行构建，那么你可以用 sass、less 或 stylus 来编写样式，并使用相应的扩展名（.scss、.less、.styl）把它们指定到 @Component.styleUrls 元数据中 CLI 的构建过程会运行相关的预处理器 @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) ... CLI 构建 ng new sassy-project --style=sass Back TO TOC 控制视图的封装模式:原生(Native)、仿真(Emulated)、无(None) 在组件的元数据上设置视图封装模式，你可以分别控制每个组件的封装模式 Native 视图包装模式使用浏览器原生 Shadow DOM 的一个废弃实现 Emulated 模式（默认值）通过预处理（并改名）CSS 代码来模拟 Shadow DOM 的行为，以达到把 CSS 样式局限在组件视图中的目的 None 意味着 Angular 不使用视图封装。 Angular 会把 CSS 添加到全局样式中。而不会应用上前面讨论过的那些作用域规则、隔离和保护等 通过组件元数据中的 encapsulation 属性来设置组件封装模式 // 通过组件元数据中的 encapsulation 属性来设置组件封装模式 // warning: few browsers support shadow DOM encapsulation at this time import { Component, ViewEncapsulation } from '@angular/core'; @Component({ selector: 'my-app', template: ` Welcome to Angular World Hello {{name}} `, styles: [` .greet { background: #369; color: white; } `], encapsulation: ViewEncapsulation.None // None | Emulated | Native }) export class AppComponent { name: string = 'Semlinker'; } Back TO TOC 查看仿真(Emulated)模式下生成的 CSS 使用默认的仿真模式时，Angular 会对组件的所有样式进行预处理，让它们模仿出标准的 Shadow CSS 作用域规则 启用了仿真模式的 Angular 应用的 DOM 树中，每个 DOM 元素都被加上了一些额外的属性 "},"Angular/knowledge/component&template/elements.html":{"url":"Angular/knowledge/component&template/elements.html","title":"Angular 自定义元素","keywords":"","body":"Angualr 自定义元素 Angular 元素 (Elements) 概览 Angular 元素就是打包成自定义元素的 Angular 组件 @angular/elements 包导出了一个 createCustomElement() API，它在 Angular 组件接口与变更检测功能和内置 DOM API 之间建立了一个桥梁 使用自定义元素 自定义元素会自举启动 —— 它们在添加到 DOM 中时就会自行启动自己，并在从 DOM 中移除时自行销毁自己 一旦自定义元素添加到了任何页面的 DOM 中，它的外观和行为就和其它的 HTML 元素一样了 工作原理 使用 createCustomElement() 函数来把组件转换成一个可注册成浏览器中自定义元素的类 注册完这个配置好的类之后，你就可以在内容中像内置 HTML 元素一样使用这个新元素了，比如直接把它加到 DOM 中 当你的自定义元素放进页面中时，浏览器会创建一个已注册类的实例。其内容是由组件模板提供的，它使用 Angular 模板语法，并且使用组件和 DOM 数据进行渲染。组件的输入属性（Property）对应于该元素的输入属性（Attribute） 把组件转换成自定义元素映射 Angular 提供了 createCustomElement() 函数，以支持把 Angular 组件及其依赖转换成自定义元素 自定义元素的浏览器支持 范例：弹窗服务 "},"Angular/knowledge/component&template/dynamic-component-loader.html":{"url":"Angular/knowledge/component&template/dynamic-component-loader.html","title":"动态组件","keywords":"","body":"动态组件加载器 指令 加载组件 解析组件 公共的 AdComponent 接口 最终的广告栏 "},"Angular/knowledge/component&template/attribute-directives.html":{"url":"Angular/knowledge/component&template/attribute-directives.html","title":"属性型指令","keywords":"","body":""},"Angular/knowledge/component&template/structural-directives.html":{"url":"Angular/knowledge/component&template/structural-directives.html","title":"结构型指令","keywords":"","body":""},"Angular/knowledge/component&template/pipes.html":{"url":"Angular/knowledge/component&template/pipes.html","title":"管道","keywords":"","body":""},"Angular/knowledge/component&template/animations.html":{"url":"Angular/knowledge/component&template/animations.html","title":"动画","keywords":"","body":""},"Angular/knowledge/dependency-injection/":{"url":"Angular/knowledge/dependency-injection/","title":"依赖注入","keywords":"","body":"依赖注入 依赖注入 依赖注入模式 Angualr 依赖注入 多级注入器 DI 实用技巧 "},"Angular/knowledge/dependency-injection/dependency-injection-pattern.html":{"url":"Angular/knowledge/dependency-injection/dependency-injection-pattern.html","title":"依赖注入模式","keywords":"","body":"依赖注入(Dependency injection)模式 依赖注入是一个很重要的设计模式，简称 DI 依赖注入让类从外部源中获得它的依赖，而不亲自创建它们 "},"Angular/knowledge/dependency-injection/dependency-injection.html":{"url":"Angular/knowledge/dependency-injection/dependency-injection.html","title":"Angular 依赖注入","keywords":"","body":"Angular依赖注入 依赖注入时用来创建对象及其依赖的其它对象的一种方式 当依赖注入系统创建某个对象实例时，会负责提供该对象所依赖的对象（称为该对象的依赖） Angular依赖注入 创建一个可注入的 HeroService 注入器 @Injectable 的 providers 数组 @NgModule 中的 providers 在组件中注册提供商 @Injectable、@NgModule、@Component 服务的提供商们 把类作为它自己的提供商 provide 对象字面量 备选的类提供商 带依赖的类提供商 别名类提供商 值提供商 工厂提供商 可以被摇树优化的提供商 注入某个服务 单例服务 组件的子注入器 测试组件 当服务需要别的服务时 依赖注入令牌 非类依赖 可选依赖 创建一个可注入的 HeroService // app/heroes/hero.service.ts import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root', }) export class HeroService { constructor() { } } 修改成如下代码 // src/app/heroes/hero.service.3.ts import { Injectable } from '@angular/core'; import { HEROES } from './mock-heroes'; @Injectable({ // we declare that this service should be created // by the root application injector. providedIn: 'root', }) export class HeroService { getHeroes() { return HEROES; } } @Injectable 修饰器时定义每个Angular 服务时的必备部分，把该类的其它部分改写为暴露一个方法 Back To TOC 注入器 服务类注册进依赖注入器(injector)之前，是一个普通的类 Angular 的依赖注入器负责创建服务的实例，并把它们注入到像 HeroListComponent 这样的类中 @Injectable 的 providers 数组 @Injectable 装饰器会指出这些服务或其它类是用来注入的，并且还能用于为这些服务提供配置项 使用类上的 @Injectable 修饰器为 HeroService 配置一个提供商 import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root', }) export class HeroService { constructor() { } } providedIn 告诉 Angular，它的根注入器要负责调用 HeroService 类的构造函数来创建一个实例，并让它在整个应用中都时可用的 @Injectable 修饰器用来配置一个服务提供商，它可以用在任何包含了 HeroModule 的注入器中 // /app/heroes/hero.service.ts import { Injectable } from '@angular/core'; import { HeroModule } from './hero.module'; import { HEROES } from './mock-heroes'; @Injectable({ // we declare that this service should be created // by any injector that includes HeroModule. providedIn: HeroModule, }) export class HeroService { getHeroes() { return HEROES; } } Back To TOC @NgModule 中的 providers 下面的代码中 AppModule 在自己的 providers 数组中注册了两个提供商 // /app/app.module.ts (providers) providers: [ UserService, { provide: APP_CONFIG, useValue: HERO_DI_CONFIG } ], 第一条使用 UserService 这个注入令牌 (injection token) 注册了 UserService 类 第二条使用 APP_CONFIG 这个注入令牌注册了一个值 (HERO_DI_CONFIG) 通过这两条注册语句，Angualr 可以向它创建的任何类中注册 UserService 或 HERO_DI_CONFIG Back To TOC 在组件中注册提供商 除了提供给全应用级或特定的 @NgModule 中之外，服务还可以提供给指定的组件，在组件级提供的服务职能只能在改组件及其子组件的注入器中使用 下面的代码中，HeroesComponent 组件在自己的 providers 数组中注册了 HeroService // app/heroes/heroes.component.ts import { Component } from '@angular/core'; import { HeroService } from './hero.service'; @Component({ selector: 'app-heroes', providers: [ HeroService ], template: ` Heroes ` }) export class HeroesComponent { } Back To TOC @Injectable、@NgModule、@Component @Injectable、@NgModule、@Component的区别在于最终的打包体积、服务的范围和服务的生命周期 在服务本身的 @Injectable 中注册提供商时，优化可以执行摇树优化，移除所有没有在应用中使用过的服务。打包体积更小 组件提供商(@Component)会注册到每个组件实例自己的注入器上，Angular 只能在该组件机器各级子组件的实例上注入这个服务，不能在其它地方注入这个服务实例；由组件提供的服务具有有限的生命周期，组件的每个服务都会有自己的服务实例，当组件实例被销毁时，服务的实例也会被销毁 Angular 模块中的 providers (@NgModule) 是注册在应用的根注入器下的，所以 Angular 可以往它所创建的任何类中注入相应的服务，一旦创建，服务的实例就会存在与改应用的全部生存期中，Angular 会把这一个服务实例注入到需求它的每个类中 Back To TOC 服务的提供商们 把类作为它自己的提供商 服务需要一个提供商 // Logger 是一个对象，是一个类 providers: [Logger] Back To TOC provide 对象字面量 // 下面两种形式等价 providers: [Logger] [{ provide: Logger, useClass: Logger }] // 对于上面的第二种形式，provide 属性保存的时令牌(token),它作为键值使用，用于定位依赖值和注册提供商 // 第二个时一个提供商定义对象 Back To TOC 备选的类提供商 有时候，你会请求一个不同的类来提供服务 // 下面代码告诉注入器，有人请求 Logger 时，返回 BetterLogger [{ provide: Logger, useClass: BetterLogger }] Back To TOC 带依赖的类提供商 假设 EventBetterLogger 可以在日志消息中显示用户名，这个日志服务从注入的 UserService 中取得用户，UserService 通常也会在应用级注入 @Injectable() export class EvenBetterLogger extends Logger { constructor(private userService: UserService) { super(); } log(message: string) { let name = this.userService.user.name; super.log(`Message to ${name}: ${message}`); } } // 配置 [ UserService, { provide: Logger, useClass: EvenBetterLogger }] Back To TOC 别名类提供商 给提供商起别名 [ NewLogger, // Alias OldLogger w/ reference to NewLogger { provide: OldLogger, useExisting: NewLogger}] Back To TOC 值提供商 将一个预先做好的对象作为提供商 定义对象 ```ts // An object in the shape of the logger service export function SilentLoggerFn() {} const silentLogger = { logs: ['Silent logger says \"Shhhhh!\". Provided via \"useValue\"'], log: SilentLoggerFn }; 使用对象 ```ts [{ provide: Logger, useValue: silentLogger }] Back To TOC 工厂提供商 当需要动态创建依赖值和注入的服务没法通过独立的源访问此信息时，使用工厂提供商 HeroService 的构造函数带上一个布尔型的标志，来控制是否显示隐藏的英雄，你可以注入 Logger，但不能注入逻辑型的isAuthorized，因此你需要通过工厂提供商创建这个 HeroServce 的新实例 // hero.service.ts (excerpt) constructor( private logger: Logger, private isAuthorized: boolean) { } getHeroes() { let auth = this.isAuthorized ? 'authorized ' : 'unauthorized'; this.logger.log(`Getting heroes for ${auth} user.`); return HEROES.filter(hero => this.isAuthorized || !hero.isSecret); } 工厂提供商需要一个工厂方法 // hero.service.provider.ts let heroServiceFactory = (logger: Logger, userService: UserService) => { return new HeroService(logger, userService.user.isAuthorized); }; HeroService 不能访问 UserService,但是工厂方法可以，把 Logger 和 UserService 注入到工厂提供商中，并且让注入器把它们传给工厂方法 // app/heroes/hero.service.provider.ts export let heroServiceProvider = { provide: HeroService, useFactory: heroServiceFactory, deps: [Logger, UserService] }; UseFactory 字段告诉 Angular：这个提供商是一个工程方法 Back To TOC 可以被摇树优化的提供商 摇树优化可以在最终打包时移除应用中从未引用过的代码 要想创建可摇树优化的服务提供商，那些原本要通过模块来指定的信息就要改为在服务自身的 @Injectable 修饰器中提供 Back To TOC 注入某个服务 HeroListComponent 应该从 HeroService 中获取这些英雄，但是不应该使用 new 来创建 HeroService，而是应该注入 HeroService 可以通过在构造函数中添加一个带有该依赖类型的参数来要求 Angular 把这个依赖注入到组件的构造函数中 下面是 HeroListComponent的构造函数，它要求注入 HeroService constructor(heroService: HeroService) 使用 DI 的代码 // hero-list.component (with DI) import { Component } from '@angular/core'; import { Hero } from './hero'; import { HeroService } from './hero.service'; @Component({ selector: 'app-hero-list', template: ` {{hero.id}} - {{hero.name}} ` }) export class HeroListComponent { heroes: Hero[]; constructor(heroService: HeroService) { this.heroes = heroService.getHeroes(); } } 没有使用 DI 的代码 // hero-list.component (without DI) import { Component } from '@angular/core'; import { HEROES } from './mock-heroes'; @Component({ selector: 'app-hero-list', template: ` {{hero.id}} - {{hero.name}} ` }) export class HeroListComponent { heroes = HEROES; } HeroListComponent 并不知道 HeroService 来自哪里 Back To TOC 单例服务 服务在每个注入器的范围内是单例的 任何一个注入器中，最多只会有同一个服务的一个实例 Angular 是一个多级注入系统，各级注入器可以创建它们自己的服务实例 Back To TOC 组件的子注入器 组件注入器是彼此对立的，每一个都会为组件提供的服务创建单独的实例 当 Angular 创建一个带有 @Component.provicers 的组件实例时，也会同时为这个实例创建一个新的子注入器 当 Angular 销毁某个组件实例时，也会销毁改组件的注入器，以及该注入器中的服务实例 Angular 是多层注入器，可以把全应用级的服务注入到组件中，比如，Angular 可以把由 HeroComponent 提供的 HeroService 和由 AppModule 提供的 UserService 注入到 HeroService 中 Back To TOC 测试组件 当服务需要别的服务时 同样用构造函数注入模式注入服务 import { Injectable } from '@angular/core'; import { HEROES } from './mock-heroes'; import { Logger } from '../logger.service'; @Injectable({ providedIn: 'root', }) export class HeroService { constructor(private logger: Logger) { } getHeroes() { this.logger.log('Getting heroes ...'); return HEROES; } } Back To TOC 依赖注入令牌 当向注入器注入提供商时，实际上时把这个提供商和一个 DI 令牌关联起来了 注入器委会一个内部的令牌-提供商映射表，这个映射表会在请求依赖时被引用到，令牌就是这个映射表总的键值 Back To TOC 非类依赖 当要注入的依赖不是类时，使用值提供商来注册一个对象 Back To TOC 可选依赖 使用参数 null constructor(@Inject(Token, null)); Back To TOC "},"Angular/knowledge/dependency-injection/hierarchical-dependency-injection.html":{"url":"Angular/knowledge/dependency-injection/hierarchical-dependency-injection.html","title":"多级注入器","keywords":"","body":"多级依赖注入器 Angular 是一个多级依赖注入系统 应用程序中有一个与组件树结构完全相同且一一对应的注入器树，可以在组件书中的任何级别上重新配置注入器 多级依赖注入器 注入器树 注入器冒泡 在不同层级再次提供同一个服务 组件注入器 服务隔离 多重编辑会话 专门的提供商 注入器树 一个应用可能有多个注入器 每个组件都有自己的注入器 Back To TOC 注入器冒泡 当一个组件申请获得一个依赖时，Angular 先尝试试用改组件自己的注入器来满足它 如果改组建的注入器没有找到对应的提供商，就把这个申请转给它父组件的注入器来处理 如果父组件注入器也无法满足这个申请，它就继续转给它的父组件的注入器 这个申请继续往上冒泡，知道到注入器或者到达祖先位置 如果达到祖先还未找到，则抛出错误 Back To TOC 在不同层级再次提供同一个服务 在注入器树中的多个层次上为指定的依赖令牌重新注册提供商，但是不建议这个做 服务会自下而上查找，遇到异地个提供商会胜出 在根模块 AppModule 中提供的服务能够被整个应用使用 Back To TOC 组件注入器 在不同的层次上重新配置一个或多个提供商的能力 Back To TOC 服务隔离 在组件的元数据中提供服务，限时服务只能在该组件中使用 // app/villains-list.component.ts @Component({ selector: 'app-villains-list', templateUrl: './villains-list.component.html', providers: [ VillainsService ] }) Back To TOC 多重编辑会话 同事进行多个任务时，保证每个任务互不影响，将任务可能会影响的部分拆成服务独立出来注入使用 Back To TOC 专门的提供商 为组件定制自己的提供商 Back To TOC "},"Angular/knowledge/testing.html":{"url":"Angular/knowledge/testing.html","title":"testing","keywords":"","body":""},"Docker/Docker/":{"url":"Docker/Docker/","title":"Docker","keywords":"","body":" Docker install_docker docker-registry "},"Docker/Docker/docker-registry.html":{"url":"Docker/Docker/docker-registry.html","title":"docker-registry","keywords":"","body":" 搭建私有registry仓库 搭建私有 registry 仓库 拉取docker-registry镜像 拉取docker-registry镜像 运行 docker-registry 查看私库镜像 推送镜像到私库 require docker 1.6.0+ 拉取docker-registry镜像 docker pull registry:latest 运行 docker-registry docker run -d \\ -p 5000:5000 \\ --restart=always \\ --name registry \\ -v /mnt/registry:/var/lib/registry \\ --privileged=true \\ registry 查看私库镜像 curl localhost:5000/v2/_catalog 推送镜像到私库 1. docker-registry 机器拉取镜像推送到仓库 docker pull centos docker images tag centos localhost:5000/centos docker push localhost:5000/centos 2.其它机器推动镜像到私库 当前机器 docker 添加 insecure-registry 地址 mac、windows在客户端中 insecure-registry 中添加 192.168.16.47:5000 linux 在 /etc/sysconfig/docker 中添加如下配置ADD_REGISTRY='--insecure-registry 192.168.16.47:5000' push 可能会出现retry，多试几次 docker pull centos docker images tag centos 192.168.16.47:5000/centos docker push 192.168.16.47:5000/centos "},"Docker/Docker/install_docker.html":{"url":"Docker/Docker/install_docker.html","title":"install_docker","keywords":"","body":"install docker-ce for centos 安装 docker-ce #！/bin/bash sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce sudo systemctl start docker 设置加速器 curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://027f9e95.m.daocloud.io sudo systemctl restart docker "},"Docker/Docker-compose/":{"url":"Docker/Docker-compose/","title":"Docker-compose","keywords":"","body":"Docker-compose "},"Docker/Docker-compose/install_docker-compose.html":{"url":"Docker/Docker-compose/install_docker-compose.html","title":"install_docker-compose","keywords":"","body":"install docker-compose for linux sudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version "},"Docker/Docker-compose/example.html":{"url":"Docker/Docker-compose/example.html","title":"example","keywords":"","body":"node + mongo + redis + mysql 1.服务目录如下 node_mysql_redis_mongo/ ├── Dockerfile # 打包文件 ├── docker-compose.yaml # service 文件 ├── root │ ├── bin │ │ └── run.sh # 服务启动文件 │ └── server # 服务文件 │ ├── app.js │ ├── package-lock.json │ └── package.json └── start.sh # 工程启动文件 1.1 Dockerfile 文件 FROM centos RUN yum -y update; yum clean all RUN yum -y install epel-release; yum clean all RUN yum -y install nodejs npm; yum clean all ADD root/ /opt/ 1.2 docker-compose.yaml文件如下 version: \"3.3\" services: mysql: image: mysql:5.7 restart: always environment: MYSQL_ROOT_PASSWORD: $Cai3564423 # mysql服务root用户初始密码 expose: # expose是暴露服务给docker-compose其他服务用，不会暴露到服务外面，ports会暴露端口到服务外面 - 3306 volumes: - /Users/clx/dockerVolume/mysql:/var/lib/mysql # 将 mysql数据挂载到本机/Users/clx/dockerVolume/mysql目录 redis: image: redis:4.0 restart: always expose: - 6379 volumes: - /Users/clx/dockerVolume/redis/:/data mongo: image: mongo:3.6 restart: always environment: - MONGO_DATA_DIR=/data/db - MONGO_LOG_DIR=/data/db/log expose: - 27017 volumes: - /Users/clx/dockerVolume/mongo/:/data/db server: # 应用名称 build: . entrypoint: \"bash -c\" depends_on: # docker-compose会将depends_on的容器先启动 - mysql - redis - mongo environment: MYSQL_HOST: mysql MYSQL_ROOT_PASSWORD: $Cai3564423 MONGO_HOST: mongo REDIS_HOST: redis 1.3 run.sh 文件 cd /opt/server npm install node app.js 1.4 app.js文件 const mysql = require(\"mysql\"); const connection = mysql.createConnection({ host: process.env.MYSQL_HOST || \"127.0.0.1\", user: \"root\", password: process.env.MYSQL_ROOT_PASSWORD || \"@Cai3564423\" }); connection.connect(function(err) { if (err) { console.error(\"mysql error connecting: \" + err.stack); return; } console.log(\"mysql connected as id \" + connection.threadId); }); const MongoClient = require(\"mongodb\"); const url = `mongodb://${process.env.MONGO_HOST}:27017`; // Use connect method to connect to the server MongoClient.connect( url, function(err, client) { if (err) { console.log(\"connected faild to mongodb server\"); } else { console.log(\"Connected successfully to mongodb server\"); } } ); const redis = require(\"redis\"); const client = redis.createClient({ host: process.env.REDIS_HOST || \"127.0.0.1\", port: \"6379\" }); // if you'd like to select database 3, instead of 0 (default), call // client.select(3, function() { /* ... */ }); client.on(\"error\", function(err) { console.log(\"Error \" + err); }); client.set(\"string key\", \"string val\", redis.print); 1.5 package-lock.json { \"name\": \"node_mysql_redis_mongo\", \"version\": \"1.0.0\", \"lockfileVersion\": 1, \"requires\": true, \"dependencies\": { \"async\": { \"version\": \"2.6.1\", \"resolved\": \"https://registry.npmjs.org/async/-/async-2.6.1.tgz\", \"integrity\": \"sha512-fNEiL2+AZt6AlAw/29Cr0UDe4sRAHCpEHh54WMz+Bb7QfNcFw4h3loofyJpLeQs4Yx7yuqu/2dLgM5hKOs6HlQ==\", \"requires\": { \"lodash\": \"^4.17.10\" } }, \"bignumber.js\": { \"version\": \"4.1.0\", \"resolved\": \"https://registry.npmjs.org/bignumber.js/-/bignumber.js-4.1.0.tgz\", \"integrity\": \"sha512-eJzYkFYy9L4JzXsbymsFn3p54D+llV27oTQ+ziJG7WFRheJcNZilgVXMG0LoZtlQSKBsJdWtLFqOD0u+U0jZKA==\" }, \"bluebird\": { \"version\": \"3.5.1\", \"resolved\": \"https://registry.npmjs.org/bluebird/-/bluebird-3.5.1.tgz\", \"integrity\": \"sha512-MKiLiV+I1AA596t9w1sQJ8jkiSr5+ZKi0WKrYGUn6d1Fx+Ij4tIj+m2WMQSGczs5jZVxV339chE8iwk6F64wjA==\" }, \"bson\": { \"version\": \"1.0.9\", \"resolved\": \"https://registry.npmjs.org/bson/-/bson-1.0.9.tgz\", \"integrity\": \"sha512-IQX9/h7WdMBIW/q/++tGd+emQr0XMdeZ6icnT/74Xk9fnabWn+gZgpE+9V+gujL3hhJOoNrnDVY7tWdzc7NUTg==\" }, \"core-util-is\": { \"version\": \"1.0.2\", \"resolved\": \"https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz\", \"integrity\": \"sha1-tf1UIgqivFq1eqtxQMlAdUUDwac=\" }, \"debug\": { \"version\": \"3.1.0\", \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.1.0.tgz\", \"integrity\": \"sha512-OX8XqP7/1a9cqkxYw2yXss15f26NKWBpDXQd0/uK/KPqdQhxbPa994hnzjcE2VqQpDslf55723cKPUOGSmMY3g==\", \"requires\": { \"ms\": \"2.0.0\" } }, \"double-ended-queue\": { \"version\": \"2.1.0-0\", \"resolved\": \"https://registry.npmjs.org/double-ended-queue/-/double-ended-queue-2.1.0-0.tgz\", \"integrity\": \"sha1-ED01J/0xUo9AGIEwyEHv3XgmTlw=\" }, \"inherits\": { \"version\": \"2.0.3\", \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz\", \"integrity\": \"sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4=\" }, \"isarray\": { \"version\": \"1.0.0\", \"resolved\": \"https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz\", \"integrity\": \"sha1-u5NdSFgsuhaMBoNJV6VKPgcSTxE=\" }, \"kareem\": { \"version\": \"2.2.1\", \"resolved\": \"https://registry.npmjs.org/kareem/-/kareem-2.2.1.tgz\", \"integrity\": \"sha512-xpDFy8OxkFM+vK6pXy6JmH92ibeEFUuDWzas5M9L7MzVmHW3jzwAHxodCPV/BYkf4A31bVDLyonrMfp9RXb/oA==\" }, \"lodash\": { \"version\": \"4.17.10\", \"resolved\": \"https://registry.npmjs.org/lodash/-/lodash-4.17.10.tgz\", \"integrity\": \"sha512-UejweD1pDoXu+AD825lWwp4ZGtSwgnpZxb3JDViD7StjQz+Nb/6l093lx4OQ0foGWNRoc19mWy7BzL+UAK2iVg==\" }, \"lodash.get\": { \"version\": \"4.4.2\", \"resolved\": \"https://registry.npmjs.org/lodash.get/-/lodash.get-4.4.2.tgz\", \"integrity\": \"sha1-LRd/ZS+jHpObRDjVNBSZ36OCXpk=\" }, \"mongodb\": { \"version\": \"3.1.3\", \"resolved\": \"https://registry.npmjs.org/mongodb/-/mongodb-3.1.3.tgz\", \"integrity\": \"sha512-hfzI54/fe+604w5gP+i9aJ5GGVxnquxZ09ZN1cyLTbpnBfDRpj78lN59SBdDRkF1VNTzmM2KcgDWhHHDHcsJxw==\", \"requires\": { \"mongodb-core\": \"3.1.2\" } }, \"mongodb-core\": { \"version\": \"3.1.2\", \"resolved\": \"https://registry.npmjs.org/mongodb-core/-/mongodb-core-3.1.2.tgz\", \"integrity\": \"sha512-R2XxGzsmhlUeOK2jKATj1TWn3q3qNcJpKrSh0rhaBSHxJmV7WZ+ikjocdY8VdJxUkKqOxM8rxMqOAEzeJ3p1ww==\", \"requires\": { \"bson\": \"^1.1.0\", \"require_optional\": \"^1.0.1\", \"saslprep\": \"^1.0.0\" }, \"dependencies\": { \"bson\": { \"version\": \"1.1.0\", \"resolved\": \"https://registry.npmjs.org/bson/-/bson-1.1.0.tgz\", \"integrity\": \"sha512-9Aeai9TacfNtWXOYarkFJRW2CWo+dRon+fuLZYJmvLV3+MiUp0bEI6IAZfXEIg7/Pl/7IWlLaDnhzTsD81etQA==\" } } }, \"mongoose\": { \"version\": \"5.2.9\", \"resolved\": \"https://registry.npmjs.org/mongoose/-/mongoose-5.2.9.tgz\", \"integrity\": \"sha512-PqXYKtXq5VPJDf7pUuCfTjN5MVEE0Dyia+YrqkI/FU8kk7YmZbGIedbvw7HHn+EKFSD2N137djhbH0NJ7FNA5Q==\", \"requires\": { \"async\": \"2.6.1\", \"bson\": \"~1.0.5\", \"kareem\": \"2.2.1\", \"lodash.get\": \"4.4.2\", \"mongodb\": \"3.1.3\", \"mongodb-core\": \"3.1.2\", \"mongoose-legacy-pluralize\": \"1.0.2\", \"mpath\": \"0.4.1\", \"mquery\": \"3.1.2\", \"ms\": \"2.0.0\", \"regexp-clone\": \"0.0.1\", \"safe-buffer\": \"5.1.2\", \"sliced\": \"1.0.1\" } }, \"mongoose-legacy-pluralize\": { \"version\": \"1.0.2\", \"resolved\": \"https://registry.npmjs.org/mongoose-legacy-pluralize/-/mongoose-legacy-pluralize-1.0.2.tgz\", \"integrity\": \"sha512-Yo/7qQU4/EyIS8YDFSeenIvXxZN+ld7YdV9LqFVQJzTLye8unujAWPZ4NWKfFA+RNjh+wvTWKY9Z3E5XM6ZZiQ==\" }, \"mpath\": { \"version\": \"0.4.1\", \"resolved\": \"https://registry.npmjs.org/mpath/-/mpath-0.4.1.tgz\", \"integrity\": \"sha512-NNY/MpBkALb9jJmjpBlIi6GRoLveLUM0pJzgbp9vY9F7IQEb/HREC/nxrixechcQwd1NevOhJnWWV8QQQRE+OA==\" }, \"mquery\": { \"version\": \"3.1.2\", \"resolved\": \"https://registry.npmjs.org/mquery/-/mquery-3.1.2.tgz\", \"integrity\": \"sha512-rBo2+eShI/Ko/GFzXMvJvYjzeLRW3P7E4NllAGRyNO90Xw5awo5RI3zCqzuJWe1NSvdL7cGu3RPLuGjZ1TmnmA==\", \"requires\": { \"bluebird\": \"3.5.1\", \"debug\": \"3.1.0\", \"regexp-clone\": \"0.0.1\", \"sliced\": \"1.0.1\" } }, \"ms\": { \"version\": \"2.0.0\", \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.0.0.tgz\", \"integrity\": \"sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=\" }, \"mysql\": { \"version\": \"2.16.0\", \"resolved\": \"https://registry.npmjs.org/mysql/-/mysql-2.16.0.tgz\", \"integrity\": \"sha512-dPbN2LHonQp7D5ja5DJXNbCLe/HRdu+f3v61aguzNRQIrmZLOeRoymBYyeThrR6ug+FqzDL95Gc9maqZUJS+Gw==\", \"requires\": { \"bignumber.js\": \"4.1.0\", \"readable-stream\": \"2.3.6\", \"safe-buffer\": \"5.1.2\", \"sqlstring\": \"2.3.1\" } }, \"process-nextick-args\": { \"version\": \"2.0.0\", \"resolved\": \"https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.0.tgz\", \"integrity\": \"sha512-MtEC1TqN0EU5nephaJ4rAtThHtC86dNN9qCuEhtshvpVBkAW5ZO7BASN9REnF9eoXGcRub+pFuKEpOHE+HbEMw==\" }, \"readable-stream\": { \"version\": \"2.3.6\", \"resolved\": \"https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.6.tgz\", \"integrity\": \"sha512-tQtKA9WIAhBF3+VLAseyMqZeBjW0AHJoxOtYqSUZNJxauErmLbVm2FW1y+J/YA9dUrAC39ITejlZWhVIwawkKw==\", \"requires\": { \"core-util-is\": \"~1.0.0\", \"inherits\": \"~2.0.3\", \"isarray\": \"~1.0.0\", \"process-nextick-args\": \"~2.0.0\", \"safe-buffer\": \"~5.1.1\", \"string_decoder\": \"~1.1.1\", \"util-deprecate\": \"~1.0.1\" } }, \"redis\": { \"version\": \"2.8.0\", \"resolved\": \"https://registry.npmjs.org/redis/-/redis-2.8.0.tgz\", \"integrity\": \"sha512-M1OkonEQwtRmZv4tEWF2VgpG0JWJ8Fv1PhlgT5+B+uNq2cA3Rt1Yt/ryoR+vQNOQcIEgdCdfH0jr3bDpihAw1A==\", \"requires\": { \"double-ended-queue\": \"^2.1.0-0\", \"redis-commands\": \"^1.2.0\", \"redis-parser\": \"^2.6.0\" } }, \"redis-commands\": { \"version\": \"1.3.5\", \"resolved\": \"https://registry.npmjs.org/redis-commands/-/redis-commands-1.3.5.tgz\", \"integrity\": \"sha512-foGF8u6MXGFF++1TZVC6icGXuMYPftKXt1FBT2vrfU9ZATNtZJ8duRC5d1lEfE8hyVe3jhelHGB91oB7I6qLsA==\" }, \"redis-parser\": { \"version\": \"2.6.0\", \"resolved\": \"https://registry.npmjs.org/redis-parser/-/redis-parser-2.6.0.tgz\", \"integrity\": \"sha1-Uu0J2srBCPGmMcB+m2mUHnoZUEs=\" }, \"regexp-clone\": { \"version\": \"0.0.1\", \"resolved\": \"https://registry.npmjs.org/regexp-clone/-/regexp-clone-0.0.1.tgz\", \"integrity\": \"sha1-p8LgmJH9vzj7sQ03b7cwA+aKxYk=\" }, \"require_optional\": { \"version\": \"1.0.1\", \"resolved\": \"https://registry.npmjs.org/require_optional/-/require_optional-1.0.1.tgz\", \"integrity\": \"sha512-qhM/y57enGWHAe3v/NcwML6a3/vfESLe/sGM2dII+gEO0BpKRUkWZow/tyloNqJyN6kXSl3RyyM8Ll5D/sJP8g==\", \"requires\": { \"resolve-from\": \"^2.0.0\", \"semver\": \"^5.1.0\" } }, \"resolve-from\": { \"version\": \"2.0.0\", \"resolved\": \"https://registry.npmjs.org/resolve-from/-/resolve-from-2.0.0.tgz\", \"integrity\": \"sha1-lICrIOlP+h2egKgEx+oUdhGWa1c=\" }, \"safe-buffer\": { \"version\": \"5.1.2\", \"resolved\": \"https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz\", \"integrity\": \"sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==\" }, \"saslprep\": { \"version\": \"1.0.1\", \"resolved\": \"https://registry.npmjs.org/saslprep/-/saslprep-1.0.1.tgz\", \"integrity\": \"sha512-ntN6SbE3hRqd45PKKadRPgA+xHPWg5lPSj2JWJdJvjTwXDDfkPVtXWvP8jJojvnm+rAsZ2b299C5NwZqq818EA==\", \"optional\": true }, \"semver\": { \"version\": \"5.5.1\", \"resolved\": \"https://registry.npmjs.org/semver/-/semver-5.5.1.tgz\", \"integrity\": \"sha512-PqpAxfrEhlSUWge8dwIp4tZnQ25DIOthpiaHNIthsjEFQD6EvqUKUDM7L8O2rShkFccYo1VjJR0coWfNkCubRw==\" }, \"sliced\": { \"version\": \"1.0.1\", \"resolved\": \"https://registry.npmjs.org/sliced/-/sliced-1.0.1.tgz\", \"integrity\": \"sha1-CzpmK10Ewxd7GSa+qCsD+Dei70E=\" }, \"sqlstring\": { \"version\": \"2.3.1\", \"resolved\": \"https://registry.npmjs.org/sqlstring/-/sqlstring-2.3.1.tgz\", \"integrity\": \"sha1-R1OT/56RR5rqYtyvDKPRSYOn+0A=\" }, \"string_decoder\": { \"version\": \"1.1.1\", \"resolved\": \"https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz\", \"integrity\": \"sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==\", \"requires\": { \"safe-buffer\": \"~5.1.0\" } }, \"util-deprecate\": { \"version\": \"1.0.2\", \"resolved\": \"https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz\", \"integrity\": \"sha1-RQ1Nyfpw3nMnYvvS1KKJgUGaDM8=\" } } } 1.6 package.json 文件 { \"name\": \"node_mysql_redis_mongo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"mongodb\": \"^3.1.3\", \"mongoose\": \"^5.2.9\", \"mysql\": \"^2.16.0\", \"redis\": \"^2.8.0\" } } 1.7 start.sh 文件 docker-compose build # 构建服务 docker-compose run server /opt/bin/run.sh # 启动server(yaml文件里面定义的名称)服务里面的 /opt/bin/run.sh 文件 2.输出结果 "},"Node/npm/config_registry.html":{"url":"Node/npm/config_registry.html","title":"配置淘宝 npm 地址","keywords":"","body":"配置 npm\b 源为淘宝镜像源 npm config set registry https://registry.npm.taobao.org --global npm config set disturl https://npm.taobao.org/dist --global "},"Node/npm/npm_registry.html":{"url":"Node/npm/npm_registry.html","title":"搭建 npm 私库","keywords":"","body":"搭建 npm registry -- Sinopia 1. 安装 Sinopia npm install sinopia -g 2. 启动 Sinopia sinopia # 或 pm2 start `which sinopia` # warn --- config file - /home/clx/.config/sinopia/config.yaml # warn --- http address - http://localhost:4873/ 3. 修改配置文件 ~/config/sinopia/config.yaml # # This is the default config file. It allows all users to do anything, # so don't use it on production systems. # # Look here for more config file examples: # https://github.com/rlidwka/sinopia/tree/master/conf # # path to a directory with all packages storage: ./storage auth: htpasswd: file: ./htpasswd # Maximum amount of users allowed to register, defaults to \"+inf\". # You can set this to -1 to disable registration. max_users: -1 # 默认为1000， 修改为 -1， 禁止客户端注册 # a list of other known repositories we can talk to uplinks: npmjs: url: https://registry.npmjs.org/ # 拉取公共包的地址源，可以修改为淘宝镜像地址 packages: # 报权限管理 '@*/*': # 内部包 # scoped packages access: $all # 表示所有人都可以执行操作 publish: $authenticated # 表示只有通过验证的用户才可以执行的操作 '*': # 公共包 # allow all users (including non-authenticated users) to read and # publish all packages # # you can specify usernames/groupnames (depending on your auth plugin) # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\" access: $all # 表示 # allow all known users to publish packages # (anyone can register by default, remember?) publish: $authenticated # if package is not available locally, proxy requests to 'npmjs' registry proxy: npmjs # 如果包寻找不到，则 proxy 到配置文件 uplinks 下 npmjs 对应的地方去寻找 # log settings logs: - {type: stdout, format: pretty, level: http} #- {type: file, path: sinopia.log, level: info} listen: 0.0.0.0:4873 # 修改服务监听，可以从外网访问 sinopia 仓库 # # packages 配置说明 # # 1. 每个过滤器有三项基本配置 # access -- 安装(install) # publish -- 发布(publish) # proxy -- 路由(对应upliks值) # # 2. access、publish 有三种值 # $all -- 所有人 # $authenticated -- 需要鉴权 # $anonymous -- 只有匿名者可以操作 修改完配置文件后重新启动 4. 客户端配置 4.1 安装 nrm 管理 npm registry npm install -g nrm 4.2 添加sinopia 仓库地址 nrm add sinopia http://192.168.xx.xx:4873 4.3 查看所有仓库地址 nrm ls npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ * sinopia http://192.168.17.209:4873/ 4.4 切换仓库地址 nrm use sinopia 5. 创建用户 5.1 客户端创建 前提是配置文件中 max_users 不能设置为 -1 npm adduser --registry http://localhost:4873/ 5.2 手动添加用户 在 ～/.config/sinopia/htpasswd 文件添加用户(没有改文件则手动创建) vim htpasswd # zza00000:{SHA}6CsImV9vbOmL87Hmi2cg0yiuGJA=:autocreated 2018-08-20T23:20:36.085Z # cai3564423:{SHA}6CsImV9vbOmL87Hmi2cg0yiuGJA=:autocreated 2018-08-20T23:40:32.396Z 加密算法为 SHA1 之后转换成 Base64 输出，最后面是时间 5.3 htpasswd-for-sinopia 添加用户 # install npm install htpasswd-for-sinopia -g # add user sinopia-adduser # 在 htpasswd 目录下执行，按提示输入用户名和密码 可以发现 htpasswd 文件后添加了一条用户信息 6.发包 与正常的npm发包一样 npm publish "},"Node/test/":{"url":"Node/test/","title":"test","keywords":"","body":" Test mocha+chai supertest "},"Node/npm/":{"url":"Node/npm/","title":"npm","keywords":"","body":""},"Node/test/supertest.html":{"url":"Node/test/supertest.html","title":"http 测试","keywords":"","body":"supertest 安装依赖 #!bin/bash mkdir test cd test npm init -y npm install mocha -g npm install chai --save-dev npm install supertest --save-dev 编写脚本 // test_supertest.js const request = require('supertest') const { assert, expect, should } = requires('chai') const url = \"http://www.baidu.com\" describe('test', () => { before(() => { // runs before all tests in this block }); after(() => { // runs after all tests in this block }); beforeEach(() => { // runs before each test in this block }); afterEach(() => { // runs after each test in this block }); // test cases it('respond with baidu.com', async () => { let res = await supestest(url) .get('/) .... }); // 可以嵌套 describe('Array', function() { describe.only('#indexOf()', function() { // ... }); }); 执行测试 mocha test_supertest.js "},"Node/test/mocha+chai.html":{"url":"Node/test/mocha+chai.html","title":"mocha+chai","keywords":"","body":"mocha+chai 安装 #!bin/bash mkdir test cd test npm init -y npm install mocha -g npm install chai --save-dev hook describe('hooks', function() { before(() => { // runs before all tests in this block }); after(() => { // runs after all tests in this block }); beforeEach(() => { // runs before each test in this block }); afterEach(() => { // runs after each test in this block }); // test cases }); "},"Openresty/lua/":{"url":"Openresty/lua/","title":"lua","keywords":"","body":" lua 获取当前时间(ms).md) "},"Openresty/lua/get_time.html":{"url":"Openresty/lua/get_time.html","title":"获取时间戳","keywords":"","body":"1.获取当前时间 -- s local t0 = os.time() -- s -- ms local socket = require \"socket\" local t1 = socket.gettime() -- us "},"Openresty/nginx/":{"url":"Openresty/nginx/","title":"nginx","keywords":"","body":" nginx配置为静态文件服务器 "},"Openresty/nginx/nginx_file_server.html":{"url":"Openresty/nginx/nginx_file_server.html","title":"nginx配置为静态文件服务器","keywords":"","body":"nginx配置为静态文件服务器 1.nginx.conf添加配置文件 server { listen 8002; server_name localhost; root /data/file; autoindex on; #开启索引功能 autoindex_exact_size on; # 关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb） autoindex_localtime on; # 显示本机时间而非 GMT 时间 } 2.浏览器打开 nginx_ip:8002 可以看见 /data/file 目录下面的所有文件 "},"Openresty/install_openresty.html":{"url":"Openresty/install_openresty.html","title":"Openresty 安装脚本","keywords":"","body":"openresty安装(centos) #!bin/bash # install_openresty yum install pcre-devel openssl-devel gcc curl wget https://openresty.org/download/openresty-1.13.6.2.tar.gz tar -xzvf openresty-1.13.6.2.tar.gz cd openresty-1.13.6.2/ ./configure make -j2 sudo make install "},"Linux/":{"url":"Linux/","title":"Linux","keywords":"","body":""},"Linux/crontab.html":{"url":"Linux/crontab.html","title":"定时任务 crontab","keywords":"","body":"crontab crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行; rontab储存的指令被守护进程激活，定时检查是否有作业需要执行，需要执行的作业称为 crontab job crontab job 使用 crontab job 文件存放在 /etc/crontab 文件，打开如下： SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 前面三行用于配置定时任务的执行环境 添加定时任务 shell 输入 crontab -e 编辑配置 /etc/crontab 文件，添加如下配置 0 * * * * /bin/ls # 每天零点执行 /bin/ls 命令 0 1-22 * * * /bin/ls # 1点到22点整执行 /bin/ls 命令 其它命令 crontab -l # 列出所有正在执行的定时任务 crontab file # 执行 file 文件里面的定时认为 "},"Linux/scp.html":{"url":"Linux/scp.html","title":"跨机器复制","keywords":"","body":"Scp 跨主机拷贝 scp file username@xxx.xxx.xxx.xxx:/root # 将文件 file 拷贝到 xxx.xxx.xxx.xxx 机器的 /root 目录 "},"Linux/term_proxy.html":{"url":"Linux/term_proxy.html","title":"命令行配置代理","keywords":"","body":"命令行实现代理 命令行执行下面代码 export proxy = 'http://localhost:port' # shadowdsocks # alias proxy = \"export all_proxy = socks5://127.0.0.1:1080\" # alias unproxy = 'unset all_proxy' 执行代理 # socks5 proxy 取消代理 unproxy "},"Devops/":{"url":"Devops/","title":"Devops","keywords":"","body":""},"Devops/microservices/":{"url":"Devops/microservices/","title":"microservices","keywords":"","body":""},"Devops/microservices/consul+consul_template.html":{"url":"Devops/microservices/consul+consul_template.html","title":"consul+consul_template","keywords":"","body":"consul 容器启动consul docker run -d \\ -p 8500:8500 \\ -v /Users/clx/dockerVolume/consul:/consul/data \\ -e CONSUL_CLIENT_INTERFACE='eth0' \\ -e CONSUL_BIND_INTERFACE='eth0' \\ consul agent -server -bootstrap-expect=1 -ui 编写模版文件 # test.lua.ctmpl return { secret = '{{ keyOrDefault \"/test/session_auth_secret\" \"623q4hR325t36VsCD3g567922IC0073T\" }}', storage = '{{ keyOrDefault \"/test/session_auth_storage\" \"redis\" }}', cookie = { secure = {{ keyOrDefault \"/test/session_auth_cookie_secure\" \"false\" }}, httponly = {{ keyOrDefault \"/test/session_auth_cookie_httponly\" \"true\" }} } } 启动 consul-template 来监听文件 consul-template -consul-addr 127.0.0.1:8500 -template \"test.lua.ctmpl:test.lua:echo kkkkk\" -once # 上面的命令会通过 test.lua.ctmpl 模版生成 test.lua，然后输出 kkkkk # -consul-addr 监听的 consul 地址 # -template 模版文件，上面命令中 该参数的值含义为 “模版文件：输出文件:执行脚本” # -once 只执行一次 通过配置文件使用 consul-template 编写配置文件 config.hcl ```hcl consul {address = \"127.0.0.1:8500\" // consul 监听地址 } template { source = \"/Users/clx/consul/test.lua.ctmpl\" // 模版文件地址 destination = \"/Users/clx/consul/test.lua\" // 模版文件输出地址 command = \"echo restart\" // 文件生成后执行命令 } 2. 启动 consule-template ```sh consul-template -config \"config.hcl\" consul-templata 命令 range 用户遍历 ervice/redis 目录下所有配置 {{ range tree \"service/redis\" }} {{ .Key }}:{{ .Value }}{{ end }} "},"Devops/jenkens_install_centos.html":{"url":"Devops/jenkens_install_centos.html","title":"Jenkins安装","keywords":"","body":"jenkins 安装脚本(centos) #!/bin/bash sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum install jenkins sudo service jenkins start "}}