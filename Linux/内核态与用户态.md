# 内核态与用户态


## 下面是其它人的一些理解
在 Linux 中每个用户进程都有 2 个堆栈，一个用户堆栈和一个专用的内核堆栈。用户堆栈驻留在用户地址空间中，内核堆栈驻留在进程的内核空间中，当用户进程需要执行某些特权操作时(系统调用)，操作将会传递给内核，然后内核执行操作。这个操作发生在内核进程的堆栈上。TSS(Task state segment)用与存储进程内核堆栈的地址段和堆栈指针；一旦系统调用开始，用户进程在将用户的操作信息推送到用户的堆栈寄存器中并执行用与系统调用的指令，然后硬件从 TSS 中找到进程的内核堆栈地址..未完


大部分情况下，我们认为内核态时一种 cpu 的特权态，在这个特权态下， CPU 可以执行这个特权态蔡允许执行的指令，访问这个特权态才运行访问的资源，这和当前的进程无关。
OS通过控制不同的特权态来控制资源分配。一般有两种方法切换特权态，一种是特殊的指令，比如x86的软中断指令，或者大部分RISC系统的系统调用指令（比如SC），第二种是执行异常或者外部中断。发生切换后，现在到底是哪个进程，其实是无所谓的。
现在说说现代LINUX如何定义线程和进程。我倾向于这样解释线程和进程:
线程本质就是堆栈，当一段程序在执行，能代表它的是他的过去和现在。"过去"在堆栈中，"现在"则是CPU的所有寄存器，如果我们要挂起一个线程，我们把寄存器也保存到堆栈中，我们就具有它的所有状态，可以随时恢复它。这是线程。
当我们切换线程的时候，同时切换它的地址空间（通过修改MMU即可），则我们认为发生了进程切换。所以进程的本质是地址空间，我们可以认为地址空间决定了进程是否发生切换。
回到最初的问题，当CPU的特权级刚刚发生切换的时候，显然和进程，线程的切换是无关的，但之后调度器是否切换线程和进程，则和具体的情形相关了。


## 自己的理解
在 Linux 中每个用户进程都有 2 个堆栈，一个用户堆栈和一个专用的内核堆栈。用户堆栈只能处理 linux 上层的操作，如果用户需要访问内核的资源，必须通过内核，内核为上层应用提供访问系统资源的接口。